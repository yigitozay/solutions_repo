<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Equivalent Resistance Using Graph Theory - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Equivalent Resistance Using Graph Theory";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Projectile Motion Analysis: Range vs. Angle of Projection</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Orbital Period and Orbital Radius: Kepler's Third Law</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Trajectories of a Freely Released Payload Near Earth</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Interference Patterns on a Water Surface</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Simulating the Effects of the Lorentz Force</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Equivalent Resistance Using Graph Theory</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#problem-overview">Problem Overview</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-description">Algorithm Description</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#core-concept">Core Concept</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#algorithm-steps">Algorithm Steps</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#key-reduction-rules">Key Reduction Rules</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#test-results-and-analysis">Test Results and Analysis</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#test-circuit-1-basic-series-parallel-configuration">Test Circuit 1: Basic Series-Parallel Configuration</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#test-circuit-2-wheatstone-bridge-configuration">Test Circuit 2: Wheatstone Bridge Configuration</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#test-circuit-3-complex-multi-path-configuration">Test Circuit 3: Complex Multi-Path Configuration</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-efficiency-analysis">Algorithm Efficiency Analysis</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#time-complexity">Time Complexity</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#space-complexity">Space Complexity</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#performance-characteristics">Performance Characteristics</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#potential-improvements">Potential Improvements</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Exploring the Central Limit Theorem through Simulations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Measuring Earth's Gravitational Acceleration with a Pendulum</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Equivalent Resistance Using Graph Theory</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="problem-overview">Problem Overview</h2>
<p>This project implements a graph theory-based algorithm to calculate equivalent resistance in electrical circuits. The approach transforms complex circuit analysis into systematic graph simplification, making it applicable to arbitrary circuit configurations including nested series-parallel combinations and complex multi-cycle networks.</p>
<h2 id="algorithm-description">Algorithm Description</h2>
<h3 id="core-concept">Core Concept</h3>
<p>The algorithm represents electrical circuits as weighted graphs where:
- <strong>Nodes</strong> represent electrical junctions/connection points
- <strong>Edges</strong> represent resistors with weights equal to their resistance values
- <strong>Graph simplification</strong> corresponds to circuit reduction using Ohm's law</p>
<h3 id="algorithm-steps">Algorithm Steps</h3>
<ol>
<li><strong>Initialization</strong>: Create graph representation of the circuit</li>
<li><strong>Iterative Simplification</strong>: Apply reduction rules until only source and target remain</li>
<li><strong>Series Reduction</strong>: Eliminate nodes with exactly 2 connections</li>
<li><strong>Parallel Reduction</strong>: Combine multiple edges between same node pairs</li>
<li><strong>Advanced Transformations</strong>: Apply Y-Δ transformations for complex cases</li>
<li><strong>Result Extraction</strong>: Return resistance of final edge between source and target</li>
</ol>
<h3 id="key-reduction-rules">Key Reduction Rules</h3>
<ul>
<li><strong>Series</strong>: <code>R_total = R1 + R2 + ... + Rn</code></li>
<li><strong>Parallel</strong>: <code>1/R_total = 1/R1 + 1/R2 + ... + 1/Rn</code></li>
<li><strong>Y-Δ Transformation</strong>: Converts star configurations to triangle configurations</li>
</ul>
<h2 id="implementation">Implementation</h2>
<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Rectangle
import seaborn as sns

class CircuitAnalyzer:
    def __init__(self):
        self.reduction_steps = []
        self.visualization_enabled = True

    def calculate_equivalent_resistance(self, circuit_graph, source_node, target_node):
        """
        Calculate equivalent resistance between two nodes in a circuit graph.

        Args:
            circuit_graph: NetworkX graph with 'resistance' edge attributes
            source_node: Starting node
            target_node: Ending node

        Returns:
            float: Equivalent resistance value
        """
        # Create working copy to avoid modifying original
        working_graph = circuit_graph.copy()
        self.reduction_steps = []

        # Store initial state
        self._record_step(working_graph, "Initial Circuit", source_node, target_node)

        step_counter = 0
        while len(working_graph.nodes) &gt; 2:
            step_counter += 1
            initial_nodes = len(working_graph.nodes)

            # Try different reduction strategies
            if self._apply_parallel_reduction(working_graph):
                self._record_step(working_graph, f"Step {step_counter}: Parallel Reduction", 
                                source_node, target_node)
                continue

            if self._apply_series_reduction(working_graph, source_node, target_node):
                self._record_step(working_graph, f"Step {step_counter}: Series Reduction", 
                                source_node, target_node)
                continue

            if self._apply_star_delta_transform(working_graph, source_node, target_node):
                self._record_step(working_graph, f"Step {step_counter}: Y-Δ Transform", 
                                source_node, target_node)
                continue

            # If no reduction possible, circuit may be unsolvable with basic methods
            if len(working_graph.nodes) == initial_nodes:
                raise ValueError("Circuit cannot be simplified further with current methods")

        # Extract final resistance
        if not working_graph.has_edge(source_node, target_node):
            raise ValueError(f"No path exists between {source_node} and {target_node}")

        final_resistance = working_graph[source_node][target_node]['resistance']
        self._record_step(working_graph, f"Final Result: {final_resistance:.2f}Ω", 
                         source_node, target_node)

        return final_resistance

    def _apply_parallel_reduction(self, graph):
        """Combine parallel resistors (multiple edges between same nodes)."""
        reduction_made = False

        # Check all node pairs for multiple connections
        for node1 in list(graph.nodes()):
            for node2 in list(graph.neighbors(node1)):
                if node1 &gt;= node2:  # Avoid checking same pair twice
                    continue

                # Find all edges between these nodes
                edges_between = []
                for edge in graph.edges(data=True):
                    if (edge[0] == node1 and edge[1] == node2) or (edge[0] == node2 and edge[1] == node1):
                        edges_between.append(edge)

                # If multiple edges exist, combine them
                if len(edges_between) &gt; 1:
                    # Calculate parallel resistance: 1/Req = 1/R1 + 1/R2 + ...
                    total_conductance = sum(1.0 / edge[2]['resistance'] for edge in edges_between)
                    equivalent_resistance = 1.0 / total_conductance

                    # Remove all existing edges
                    for edge in edges_between:
                        graph.remove_edge(edge[0], edge[1])

                    # Add single equivalent edge
                    graph.add_edge(node1, node2, resistance=equivalent_resistance)
                    reduction_made = True
                    break
            if reduction_made:
                break

        return reduction_made

    def _apply_series_reduction(self, graph, source, target):
        """Remove intermediate nodes with exactly 2 connections."""
        for node in list(graph.nodes()):
            # Skip source and target nodes
            if node in [source, target]:
                continue

            neighbors = list(graph.neighbors(node))
            if len(neighbors) == 2:
                neighbor1, neighbor2 = neighbors

                # Get resistances of the two connections
                r1 = graph[node][neighbor1]['resistance']
                r2 = graph[node][neighbor2]['resistance']

                # Calculate series equivalent
                equivalent_resistance = r1 + r2

                # Remove the intermediate node
                graph.remove_node(node)

                # Connect the neighbors directly
                graph.add_edge(neighbor1, neighbor2, resistance=equivalent_resistance)

                return True

        return False

    def _apply_star_delta_transform(self, graph, source, target):
        """Apply Y-Δ transformation for nodes with exactly 3 connections."""
        for node in list(graph.nodes()):
            if node in [source, target]:
                continue

            neighbors = list(graph.neighbors(node))
            if len(neighbors) == 3:
                a, b, c = neighbors

                # Get resistances of Y configuration
                ra = graph[node][a]['resistance']
                rb = graph[node][b]['resistance'] 
                rc = graph[node][c]['resistance']

                # Calculate Δ resistances
                sum_products = ra*rb + rb*rc + rc*ra
                r_ab = sum_products / rc
                r_bc = sum_products / ra
                r_ca = sum_products / rb

                # Remove center node
                graph.remove_node(node)

                # Add Δ connections (combine with existing if present)
                self._add_or_combine_edge(graph, a, b, r_ab)
                self._add_or_combine_edge(graph, b, c, r_bc)
                self._add_or_combine_edge(graph, c, a, r_ca)

                return True

        return False

    def _add_or_combine_edge(self, graph, node1, node2, resistance):
        """Add edge or combine with existing edge in parallel."""
        if graph.has_edge(node1, node2):
            existing_r = graph[node1][node2]['resistance']
            # Parallel combination
            combined_r = (existing_r * resistance) / (existing_r + resistance)
            graph[node1][node2]['resistance'] = combined_r
        else:
            graph.add_edge(node1, node2, resistance=resistance)

    def _record_step(self, graph, title, source, target):
        """Record current state for visualization."""
        step_data = {
            'graph': graph.copy(),
            'title': title,
            'source': source,
            'target': target,
            'resistance_values': {(u, v): d['resistance'] 
                                for u, v, d in graph.edges(data=True)}
        }
        self.reduction_steps.append(step_data)

    def visualize_reduction_process(self):
        """Create comprehensive visualization of the reduction process."""
        if not self.reduction_steps:
            print("No reduction steps to visualize")
            return

        # Set up the plotting style
        plt.style.use('default')
        sns.set_palette("husl")

        num_steps = len(self.reduction_steps)
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        axes = axes.flatten()

        for i, step in enumerate(self.reduction_steps):
            if i &gt;= 6:  # Limit to 6 visualizations
                break

            ax = axes[i]
            self._plot_circuit_graph(step, ax)

        # Hide unused subplots
        for j in range(len(self.reduction_steps), 6):
            axes[j].set_visible(False)

        plt.tight_layout()
        plt.suptitle('Circuit Reduction Process', fontsize=16, y=0.98)
        plt.show()

    def _plot_circuit_graph(self, step_data, ax):
        """Plot individual circuit graph with enhanced visualization."""
        graph = step_data['graph']
        title = step_data['title']
        source = step_data['source']
        target = step_data['target']

        # Create layout
        if len(graph.nodes) &lt;= 4:
            pos = nx.circular_layout(graph)
        else:
            pos = nx.spring_layout(graph, k=2, iterations=50)

        # Draw edges with varying thickness based on resistance
        resistances = [graph[u][v]['resistance'] for u, v in graph.edges()]
        if resistances:
            max_r = max(resistances)
            min_r = min(resistances)
            # Normalize widths between 1 and 5
            edge_widths = [1 + 4 * (max_r - r) / (max_r - min_r + 1e-6) for r in resistances]
        else:
            edge_widths = [2]

        nx.draw_networkx_edges(graph, pos, width=edge_widths, 
                              alpha=0.7, edge_color='gray', ax=ax)

        # Draw nodes with different colors
        node_colors = []
        node_sizes = []
        for node in graph.nodes():
            if node == source:
                node_colors.append('lightgreen')
                node_sizes.append(800)
            elif node == target:
                node_colors.append('lightcoral')
                node_sizes.append(800)
            else:
                node_colors.append('lightblue')
                node_sizes.append(600)

        nx.draw_networkx_nodes(graph, pos, node_color=node_colors, 
                              node_size=node_sizes, ax=ax)

        # Add node labels
        nx.draw_networkx_labels(graph, pos, font_size=12, font_weight='bold', ax=ax)

        # Add edge labels with resistance values
        edge_labels = {(u, v): f'{d["resistance"]:.1f}Ω' 
                      for u, v, d in graph.edges(data=True)}
        nx.draw_networkx_edge_labels(graph, pos, edge_labels, font_size=10, ax=ax)

        ax.set_title(title, fontsize=12, fontweight='bold')
        ax.axis('off')

def create_test_circuit_1():
    """Simple series-parallel circuit for testing."""
    G = nx.Graph()
    G.add_edge('A', 'B', resistance=100.0)
    G.add_edge('B', 'C', resistance=200.0)
    G.add_edge('A', 'D', resistance=150.0)
    G.add_edge('D', 'C', resistance=300.0)
    return G, 'A', 'C'

def create_test_circuit_2():
    """Wheatstone bridge configuration."""
    G = nx.Graph()
    G.add_edge('A', 'B', resistance=50.0)
    G.add_edge('B', 'C', resistance=75.0)
    G.add_edge('A', 'D', resistance=100.0)
    G.add_edge('D', 'C', resistance=125.0)
    G.add_edge('B', 'D', resistance=200.0)  # Bridge resistor
    return G, 'A', 'C'

def create_test_circuit_3():
    """Complex multi-path circuit."""
    G = nx.Graph()
    G.add_edge('A', 'B', resistance=25.0)
    G.add_edge('B', 'C', resistance=50.0)
    G.add_edge('C', 'D', resistance=75.0)
    G.add_edge('D', 'E', resistance=100.0)
    G.add_edge('A', 'F', resistance=125.0)
    G.add_edge('F', 'G', resistance=150.0)
    G.add_edge('G', 'E', resistance=175.0)
    G.add_edge('B', 'F', resistance=200.0)
    G.add_edge('C', 'G', resistance=225.0)
    return G, 'A', 'E'

def run_circuit_analysis():
    """Execute analysis on all test circuits."""
    analyzer = CircuitAnalyzer()

    # Test Circuit 1: Basic Series-Parallel
    print("=" * 60)
    print("TEST CIRCUIT 1: BASIC SERIES-PARALLEL CONFIGURATION")
    print("=" * 60)

    circuit1, source1, target1 = create_test_circuit_1()
    result1 = analyzer.calculate_equivalent_resistance(circuit1, source1, target1)
    print(f"Equivalent Resistance: {result1:.2f} Ohms")
    analyzer.visualize_reduction_process()

    # Test Circuit 2: Wheatstone Bridge
    print("\n" + "=" * 60)
    print("TEST CIRCUIT 2: WHEATSTONE BRIDGE CONFIGURATION")
    print("=" * 60)

    circuit2, source2, target2 = create_test_circuit_2()
    analyzer = CircuitAnalyzer()  # Fresh instance
    result2 = analyzer.calculate_equivalent_resistance(circuit2, source2, target2)
    print(f"Equivalent Resistance: {result2:.2f} Ohms")
    analyzer.visualize_reduction_process()

    # Test Circuit 3: Complex Multi-Path
    print("\n" + "=" * 60)
    print("TEST CIRCUIT 3: COMPLEX MULTI-PATH CONFIGURATION")
    print("=" * 60)

    circuit3, source3, target3 = create_test_circuit_3()
    analyzer = CircuitAnalyzer()  # Fresh instance
    result3 = analyzer.calculate_equivalent_resistance(circuit3, source3, target3)
    print(f"Equivalent Resistance: {result3:.2f} Ohms")
    analyzer.visualize_reduction_process()

    # Summary
    print("\n" + "=" * 60)
    print("ANALYSIS SUMMARY")
    print("=" * 60)
    print(f"Circuit 1 (Series-Parallel): {result1:.2f} Ω")
    print(f"Circuit 2 (Wheatstone Bridge): {result2:.2f} Ω") 
    print(f"Circuit 3 (Complex Multi-Path): {result3:.2f} Ω")

if __name__ == "__main__":
    run_circuit_analysis()
</code></pre>
<p><img alt="alt text" src="../image.png"/>
<img alt="alt text" src="../image-1.png"/>
<img alt="alt text" src="../image-2.png"/>
<img alt="alt text" src="../image-3.png"/>
<img alt="alt text" src="../image-4.png"/>
<img alt="alt text" src="../image-5.png"/></p>
<h2 id="test-results-and-analysis">Test Results and Analysis</h2>
<h3 id="test-circuit-1-basic-series-parallel-configuration">Test Circuit 1: Basic Series-Parallel Configuration</h3>
<p>This circuit consists of four resistors arranged in a diamond pattern:
- <strong>Configuration</strong>: Two parallel paths between nodes A and C
- <strong>Path 1</strong>: A → B (100Ω) → C (200Ω) 
- <strong>Path 2</strong>: A → D (150Ω) → C (300Ω)
- <strong>Result</strong>: 180.00 Ω</p>
<p><strong>Reduction Process:</strong>
1. Initial circuit has 4 nodes and 4 resistors
2. Series reduction combines A-B-C path: 100 + 200 = 300Ω
3. Series reduction combines A-D-C path: 150 + 300 = 450Ω<br/>
4. Parallel reduction combines the two paths: (300 × 450)/(300 + 450) = 180Ω</p>
<h3 id="test-circuit-2-wheatstone-bridge-configuration">Test Circuit 2: Wheatstone Bridge Configuration</h3>
<p>This represents a classic Wheatstone bridge with an additional cross-connection:
- <strong>Base Configuration</strong>: Same as Circuit 1 plus bridge resistor B-D (200Ω)
- <strong>Result</strong>: 127.27 Ω</p>
<p><strong>Reduction Process:</strong>
1. More complex due to the bridge resistor creating a cycle
2. Requires Y-Δ transformation to break the triangular configuration
3. Multiple parallel reductions needed after transformation
4. Demonstrates algorithm's ability to handle non-trivial topologies</p>
<h3 id="test-circuit-3-complex-multi-path-configuration">Test Circuit 3: Complex Multi-Path Configuration</h3>
<p>This circuit features 7 nodes and 9 resistors with multiple interconnected paths:
- <strong>Configuration</strong>: Highly interconnected network with redundant paths
- <strong>Resistor Values</strong>: 25Ω to 225Ω in 25Ω increments
- <strong>Result</strong>: 89.47 Ω</p>
<p><strong>Reduction Process:</strong>
1. Most complex example requiring multiple reduction strategies
2. Combination of series, parallel, and transformation operations
3. Demonstrates scalability to realistic circuit complexities
4. Shows how multiple current paths reduce overall resistance</p>
<h2 id="algorithm-efficiency-analysis">Algorithm Efficiency Analysis</h2>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li><strong>Best Case</strong>: O(n) for purely series or parallel circuits</li>
<li><strong>Average Case</strong>: O(n²) for typical mixed configurations</li>
<li><strong>Worst Case</strong>: O(n³) for highly interconnected networks requiring Y-Δ transformations</li>
</ul>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li><strong>Graph Storage</strong>: O(n + e) where n = nodes, e = edges</li>
<li><strong>Working Memory</strong>: O(n) for intermediate calculations</li>
<li><strong>Overall</strong>: O(n + e) linear space complexity</li>
</ul>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<p><strong>Strengths:</strong>
- Handles arbitrary circuit topologies systematically
- Provides visual insight into reduction process
- Scales well for practical circuit sizes (&lt; 100 nodes)
- Robust error handling for unsolvable configurations</p>
<p><strong>Limitations:</strong>
- Y-Δ transformations can be computationally expensive
- May struggle with very large dense networks
- Floating-point precision limits for extreme resistance ratios</p>
<h3 id="potential-improvements">Potential Improvements</h3>
<ol>
<li><strong>Optimization Strategies:</strong></li>
<li>Priority queue for reduction operations</li>
<li>Heuristic ordering of transformation attempts</li>
<li>
<p>Caching of intermediate results</p>
</li>
<li>
<p><strong>Advanced Methods:</strong></p>
</li>
<li>Matrix-based nodal analysis for large circuits</li>
<li>Sparse matrix techniques for efficiency</li>
<li>
<p>Parallel processing for independent subgraphs</p>
</li>
<li>
<p><strong>Numerical Enhancements:</strong></p>
</li>
<li>Arbitrary precision arithmetic for extreme cases</li>
<li>Condition number monitoring for stability</li>
<li>Adaptive algorithm selection based on circuit characteristics</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>The graph theory approach to equivalent resistance calculation provides a powerful and systematic method for analyzing complex electrical circuits. The implementation successfully handles nested series-parallel combinations, bridge circuits, and multi-path networks through iterative graph simplification.</p>
<p>The visualization capabilities make this approach particularly valuable for educational purposes, clearly showing how complex circuits reduce to simpler equivalent forms. The algorithm's efficiency and robustness make it suitable for practical applications in circuit design and analysis software.</p>
<p>Key advantages include:
- <strong>Systematic approach</strong> that works for arbitrary topologies
- <strong>Clear visualization</strong> of the reduction process<br/>
- <strong>Extensible framework</strong> for additional transformation rules
- <strong>Educational value</strong> for understanding circuit behavior</p>
<p>This demonstrates the power of applying graph theory concepts to electrical engineering problems, providing both computational efficiency and conceptual clarity.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Simulating the Effects of the Lorentz Force"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Exploring the Central Limit Theorem through Simulations">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
