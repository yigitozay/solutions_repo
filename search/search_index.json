{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion Analysis: Range vs. Angle of Projection 1. Theoretical Foundation Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity Horizontal motion: No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\) Vertical motion: Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\) Trajectory equation: Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas 2. Range Analysis Range formula (for ground-level launch): \\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance Angle dependence: Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch) Parameter effects: Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\) 3. Practical Applications Sports applications: Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots Engineering applications: Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles Space exploration: Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth 4. Implementation Computational approach: Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization Key visualizations: Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity Simulation capabilities: Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments 5. Limitations and Extensions Current limitations: No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces Possible improvements: Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions Python Implementation # Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-range-vs-angle-of-projection","text":"","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\)","title":"Horizontal motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\)","title":"Vertical motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas","title":"Trajectory equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis","text":"","title":"2. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula-for-ground-level-launch","text":"\\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance","title":"Range formula (for ground-level launch):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#angle-dependence","text":"Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch)","title":"Angle dependence:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\)","title":"Parameter effects:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports-applications","text":"Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots","title":"Sports applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering-applications","text":"Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles","title":"Engineering applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-exploration","text":"Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth","title":"Space exploration:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-approach","text":"Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization","title":"Computational approach:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-visualizations","text":"Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity","title":"Key visualizations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-capabilities","text":"Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments","title":"Simulation capabilities:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#current-limitations","text":"No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces","title":"Current limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-improvements","text":"Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions","title":"Possible improvements:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-implementation","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum 1. Theoretical Foundation Basic Pendulum Model A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve. Resonance Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing 2. Different Behaviors Effect of Damping Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates Effect of Force Strength Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable Effect of Force Frequency Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements Chaos When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random) 3. Real-World Applications Engineering Examples Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy Similar Systems Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings 4. Computer Simulation Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior Key Visualizations Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum() 5. Limitations and Extensions Current Limitations Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force Possible Improvements Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other Summary The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#basic-pendulum-model","text":"A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve.","title":"Basic Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-different-behaviors","text":"","title":"2. Different Behaviors"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping","text":"Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates","title":"Effect of Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-strength","text":"Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable","title":"Effect of Force Strength"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-frequency","text":"Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements","title":"Effect of Force Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos","text":"When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random)","title":"Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#engineering-examples","text":"Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy","title":"Engineering Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#similar-systems","text":"Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings","title":"Similar Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computer-simulation","text":"Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior","title":"4. Computer Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-visualizations","text":"Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos","title":"Key Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum()","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#current-limitations","text":"Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force","title":"Current Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-improvements","text":"Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other","title":"Possible Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law 1. Theoretical Foundation Derivation of Kepler's Third Law for Circular Orbits To derive the relationship between orbital period and orbital radius, we begin with Newton's Law of Universal Gravitation and the principles of circular motion. For a body of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force necessary for circular motion: \\[ F_{gravitational} = F_{centripetal} \\] \\[ \\frac{G \\cdot M \\cdot m}{r^2} = m \\cdot \\frac{v^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity Simplifying by canceling \\(m\\) from both sides: \\[ \\frac{G \\cdot M}{r^2} = \\frac{v^2}{r} \\] \\[ \\frac{G \\cdot M}{r} = v^2 \\] For circular motion, the orbital period \\(T\\) relates to the orbital radius and velocity by: \\[ T = \\frac{2\\pi r}{v} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substituting our expression for \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^2}{\\frac{G \\cdot M}{r}} = \\frac{4\\pi^2 r^3}{G \\cdot M} \\] This gives us Kepler's Third Law: \\[ T^2 = \\left(\\frac{4\\pi^2}{G \\cdot M}\\right) \\cdot r^3 \\] This shows that \\(T^2 \\propto r^3\\) , or the square of the orbital period is proportional to the cube of the orbital radius . For different bodies orbiting the same central mass (e.g., different planets around the Sun), the term \\(\\frac{4\\pi^2}{G \\cdot M}\\) is constant, giving us: \\[ \\frac{T^2}{r^3} = \\text{constant} \\] This is the formulation that Kepler originally discovered through observational data, before Newton provided the theoretical explanation. 2. Astronomical Implications Determining Planetary Masses Kepler's Third Law provides a powerful method for determining the masses of celestial bodies. If we know the orbital period and radius of an orbiting body, we can calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] This allows astronomers to: - Calculate the Sun's mass by observing planetary orbits - Determine the masses of other stars by observing their planetary systems - Calculate the masses of planets by observing their moons Determining Astronomical Distances Given the mass of a central body and the orbital period of an orbiting body, we can calculate the orbital radius: \\[ r = \\sqrt[3]{\\frac{G \\cdot M \\cdot T^2}{4\\pi^2}} \\] This principle helps in: - Calculating distances within our Solar System - Estimating the size of exoplanetary systems - Mapping the structure of binary star systems Characterizing Exoplanetary Systems For exoplanets, where direct measurement of orbital radius is challenging, astronomers can: - Measure the orbital period through transit timing or radial velocity methods - Estimate the star's mass through spectroscopic analysis - Calculate the orbital radius using Kepler's Third Law This has been crucial in mapping the architecture of thousands of exoplanetary systems discovered to date. 3. Real-World Examples The Earth-Moon System For the Earth-Moon system: - Moon's mean orbital radius: \\(r \\approx 384,400\\) km - Moon's orbital period: \\(T \\approx 27.32\\) days \\(\\approx 2,360,448\\) seconds Using Kepler's Third Law: \\[ M_{Earth} = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] \\[ M_{Earth} \\approx \\frac{4\\pi^2 \\cdot (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] This closely matches Earth's known mass, confirming the relationship. Planets in the Solar System Planet Mean Orbital Radius (AU) Orbital Period (years) \\(T^2/r^3\\) Mercury 0.387 0.241 1.00 Venus 0.723 0.615 1.00 Earth 1.000 1.000 1.00 Mars 1.524 1.881 1.00 Jupiter 5.203 11.86 1.00 Saturn 9.537 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.07 164.8 1.00 The \\(T^2/r^3\\) value is normalized to 1 for all planets, demonstrating that the relationship holds throughout the Solar System. Jupiter's Moons Jupiter's four largest moons (the Galilean moons) provide another excellent example: Moon Mean Orbital Radius (km) Orbital Period (days) \\(T^2/r^3\\) (constant) Io 421,800 1.769 \\(1.77 \\times 10^{-16}\\) Europa 671,100 3.551 \\(1.77 \\times 10^{-16}\\) Ganymede 1,070,400 7.155 \\(1.77 \\times 10^{-16}\\) Callisto 1,882,700 16.69 \\(1.77 \\times 10^{-16}\\) The constant \\(T^2/r^3\\) value across all four moons confirms Kepler's Third Law and allows us to calculate Jupiter's mass. 4. Extension to Elliptical Orbits Generalized Form of Kepler's Third Law For elliptical orbits, Kepler's Third Law still applies, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot M} \\] This means the relationship between period and semi-major axis holds regardless of the eccentricity of the orbit. Implications for Comets and Asteroids Bodies with highly elliptical orbits, such as comets, still follow Kepler's Third Law. For example, Halley's Comet: - Orbital period: ~76 years - Semi-major axis: ~17.8 AU This relationship allows astronomers to predict when comets will return to the inner Solar System, even with very elongated orbits. Binary Star Systems For binary star systems, where two stars orbit their common center of mass, a modified version applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot (M_1 + M_2)} \\] Where \\(M_1\\) and \\(M_2\\) are the masses of the two stars and \\(a\\) is the semi-major axis of their orbit. 5. Computational Analysis In the accompanying Python simulation, we demonstrate: Visualization of circular orbits for various orbital radii Verification of the \\(T^2 \\propto r^3\\) relationship Application to real planetary data Interactive exploration of how changing parameters affects orbital dynamics The simulation confirms that Kepler's Third Law holds across a wide range of scales, from satellite orbits around Earth to planets orbiting distant stars. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) def calculate_orbital_period(radius, central_mass): \"\"\" Calculate orbital period using Kepler's Third Law. Parameters: radius (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def generate_circular_orbit(radius, num_points=1000): \"\"\" Generate points for a circular orbit. Parameters: radius (float): Orbital radius num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y def plot_circular_orbits(radii, central_mass, planet_names=None): \"\"\" Plot multiple circular orbits with different radii. Parameters: radii (list): List of orbital radii central_mass (float): Mass of the central body planet_names (list): Optional list of names for the orbiting bodies \"\"\" plt.figure(figsize=(10, 10)) # Plot central body plt.plot(0, 0, 'yo', markersize=15, label='Central Body') # Calculate periods and plot orbits periods = [] for i, radius in enumerate(radii): x, y = generate_circular_orbit(radius) period = calculate_orbital_period(radius, central_mass) periods.append(period) name = f\"Body {i+1}\" if planet_names is None else planet_names[i] plt.plot(x, y, '--', alpha=0.6) plt.plot(x[0], y[0], 'o', markersize=8, label=f\"{name}: T = {period:.2e} s\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbits with Different Radii') plt.grid(True, alpha=0.3) plt.axis('equal') plt.legend() plt.tight_layout() plt.savefig('circular_orbits.png', dpi=300) plt.show() return radii, periods def verify_keplers_third_law(radii, periods): \"\"\" Verify Kepler's Third Law by plotting T^2 vs r^3. Parameters: radii (list): List of orbital radii periods (list): List of corresponding orbital periods \"\"\" # Calculate T^2 and r^3 t_squared = [period**2 for period in periods] r_cubed = [radius**3 for radius in radii] # Calculate the constant T^2/r^3 constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, t_squared, s=80, alpha=0.7) # Fit a line to verify the relationship coefficients = np.polyfit(r_cubed, t_squared, 1) poly = np.poly1d(coefficients) r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) plt.plot(r3_line, poly(r3_line), 'r--') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, alpha=0.3) # Add text showing the relationship plt.text(0.05, 0.9, f'T\u00b2 = {coefficients[0]:.4e} \u00d7 r\u00b3 + {coefficients[1]:.4e}', transform=plt.gca().transAxes, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) plt.tight_layout() plt.savefig('keplers_third_law_verification.png', dpi=300) plt.show() return constants def solar_system_verification(): \"\"\" Verify Kepler's Third Law using real Solar System data. \"\"\" # Solar system data (planets) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Semi-major axes in AU radii_au = [0.387, 0.723, 1.000, 1.524, 5.203, 9.537, 19.19, 30.07] # Convert AU to meters au_to_m = 1.496e11 radii_m = [r * au_to_m for r in radii_au] # Orbital periods in years periods_yr = [0.241, 0.615, 1.000, 1.881, 11.86, 29.46, 84.01, 164.8] # Convert years to seconds yr_to_s = 365.25 * 24 * 3600 periods_s = [p * yr_to_s for p in periods_yr] # Calculate T^2/r^3 for each planet (should be constant) t_squared = [p**2 for p in periods_s] r_cubed = [r**3 for r in radii_m] constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Sun's mass sun_mass = 1.989e30 # kg # Theoretical constant theoretical_constant = 4 * np.pi**2 / (G * sun_mass) # Create a table plt.figure(figsize=(12, 8)) plt.axis('off') table_data = [] table_data.append(['Planet', 'Radius (AU)', 'Period (years)', 'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)', 'Ratio to Earth']) for i, planet in enumerate(planets): # Calculate ratio of T\u00b2/r\u00b3 to Earth's value ratio = constants[i] / constants[2] # Earth is index 2 table_data.append([planet, f\"{radii_au[i]:.3f}\", f\"{periods_yr[i]:.3f}\", f\"{constants[i]:.4e}\", f\"{ratio:.6f}\"]) # Plot the table table = plt.table(cellText=table_data, loc='center', cellLoc='center', colWidths=[0.15, 0.15, 0.15, 0.22, 0.15]) table.auto_set_font_size(False) table.set_fontsize(10) table.scale(1, 1.5) plt.title(\"Verification of Kepler's Third Law in the Solar System\", y=0.8) # Add text showing the theoretical constant plt.text(0.5, 0.1, f'Theoretical value of T\u00b2/r\u00b3 = 4\u03c0\u00b2/(G\u00b7M_\u2609) = {theoretical_constant:.4e} s\u00b2/m\u00b3', horizontalalignment='center', fontsize=12, bbox=dict(facecolor='white', alpha=0.8), transform=plt.gcf().transFigure) plt.tight_layout() plt.savefig('solar_system_verification.png', dpi=300) plt.show() # Plot T^2 vs r^3 for Solar System plt.figure(figsize=(10, 6)) plt.scatter(r_cubed, t_squared, s=100, alpha=0.7) # Add planet labels for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Plot the theoretical line r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) t2_line = theoretical_constant * r3_line plt.plot(r3_line, t2_line, 'r--', label=f'T\u00b2 = {theoretical_constant:.4e} \u00d7 r\u00b3') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('Kepler\\'s Third Law for Solar System Planets') plt.grid(True, alpha=0.3) plt.legend() # Use log scale due to wide range of values plt.xscale('log') plt.yscale('log') plt.tight_layout() plt.savefig('solar_system_plot.png', dpi=300) plt.show() return planets, radii_au, periods_yr, constants def animate_orbit(radius, central_mass, num_frames=200): \"\"\" Create an animation of an orbiting body. Parameters: radius (float): Orbital radius central_mass (float): Mass of the central body num_frames (int): Number of frames in the animation Returns: FuncAnimation: Animation object \"\"\" # Calculate orbital period period = calculate_orbital_period(radius, central_mass) # Generate the orbit theta = np.linspace(0, 2*np.pi, num_frames) x = radius * np.cos(theta) y = radius * np.sin(theta) # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-radius*1.2, radius*1.2) ax.set_ylim(-radius*1.2, radius*1.2) ax.grid(True, alpha=0.3) # Plot central body ax.plot(0, 0, 'yo', markersize=15) # Plot the orbit path ax.plot(x, y, '--', alpha=0.3) # Create moving point for the orbiting body point, = ax.plot([], [], 'bo', markersize=10) # Text for displaying time time_text = ax.text(0.05, 0.95, '', transform=ax.transAxes) # Text for displaying period information ax.text(0.05, 0.90, f'Orbital period: {period:.2e} s', transform=ax.transAxes, bbox=dict(facecolor='white', alpha=0.7)) def init(): point.set_data([], []) time_text.set_text('') return point, time_text def update(frame): point.set_data(x[frame], y[frame]) time_text.set_text(f'Time: {frame/num_frames * period:.2e} s') return point, time_text ani = FuncAnimation(fig, update, frames=num_frames, init_func=init, interval=50, blit=True) plt.title(f'Orbital Motion (r = {radius:.2e} m)') plt.tight_layout() return ani def main(): \"\"\"Main function to run all simulations.\"\"\" print(\"Kepler's Third Law Simulation\") print(\"-\" * 30) # Earth-like central mass earth_mass = 5.972e24 # kg # Simulate orbits of different satellites print(\"\\n1. Simulating Earth Satellites\") satellite_radii = [7.0e6, 1.0e7, 2.0e7, 4.2e7] # Orbit radii in meters satellite_names = [\"Low Earth Orbit\", \"Mid Earth Orbit\", \"Geostationary\", \"Lunar Distance\"] radii, periods = plot_circular_orbits(satellite_radii, earth_mass, satellite_names) constants = verify_keplers_third_law(radii, periods) print(f\"Average T\u00b2/r\u00b3 constant: {np.mean(constants):.4e} s\u00b2/m\u00b3\") print(f\"Theoretical value: {4 * np.pi**2 / (G * earth_mass):.4e} s\u00b2/m\u00b3\") # Verify with Solar System data print(\"\\n2. Verifying with Solar System Data\") solar_system_verification() print(\"\\nSimulation complete! All plots have been saved.\") if __name__ == \"__main__\": main()","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"To derive the relationship between orbital period and orbital radius, we begin with Newton's Law of Universal Gravitation and the principles of circular motion. For a body of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force necessary for circular motion: \\[ F_{gravitational} = F_{centripetal} \\] \\[ \\frac{G \\cdot M \\cdot m}{r^2} = m \\cdot \\frac{v^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity Simplifying by canceling \\(m\\) from both sides: \\[ \\frac{G \\cdot M}{r^2} = \\frac{v^2}{r} \\] \\[ \\frac{G \\cdot M}{r} = v^2 \\] For circular motion, the orbital period \\(T\\) relates to the orbital radius and velocity by: \\[ T = \\frac{2\\pi r}{v} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substituting our expression for \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^2}{\\frac{G \\cdot M}{r}} = \\frac{4\\pi^2 r^3}{G \\cdot M} \\] This gives us Kepler's Third Law: \\[ T^2 = \\left(\\frac{4\\pi^2}{G \\cdot M}\\right) \\cdot r^3 \\] This shows that \\(T^2 \\propto r^3\\) , or the square of the orbital period is proportional to the cube of the orbital radius . For different bodies orbiting the same central mass (e.g., different planets around the Sun), the term \\(\\frac{4\\pi^2}{G \\cdot M}\\) is constant, giving us: \\[ \\frac{T^2}{r^3} = \\text{constant} \\] This is the formulation that Kepler originally discovered through observational data, before Newton provided the theoretical explanation.","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-planetary-masses","text":"Kepler's Third Law provides a powerful method for determining the masses of celestial bodies. If we know the orbital period and radius of an orbiting body, we can calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] This allows astronomers to: - Calculate the Sun's mass by observing planetary orbits - Determine the masses of other stars by observing their planetary systems - Calculate the masses of planets by observing their moons","title":"Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-astronomical-distances","text":"Given the mass of a central body and the orbital period of an orbiting body, we can calculate the orbital radius: \\[ r = \\sqrt[3]{\\frac{G \\cdot M \\cdot T^2}{4\\pi^2}} \\] This principle helps in: - Calculating distances within our Solar System - Estimating the size of exoplanetary systems - Mapping the structure of binary star systems","title":"Determining Astronomical Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#characterizing-exoplanetary-systems","text":"For exoplanets, where direct measurement of orbital radius is challenging, astronomers can: - Measure the orbital period through transit timing or radial velocity methods - Estimate the star's mass through spectroscopic analysis - Calculate the orbital radius using Kepler's Third Law This has been crucial in mapping the architecture of thousands of exoplanetary systems discovered to date.","title":"Characterizing Exoplanetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-earth-moon-system","text":"For the Earth-Moon system: - Moon's mean orbital radius: \\(r \\approx 384,400\\) km - Moon's orbital period: \\(T \\approx 27.32\\) days \\(\\approx 2,360,448\\) seconds Using Kepler's Third Law: \\[ M_{Earth} = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] \\[ M_{Earth} \\approx \\frac{4\\pi^2 \\cdot (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] This closely matches Earth's known mass, confirming the relationship.","title":"The Earth-Moon System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Mean Orbital Radius (AU) Orbital Period (years) \\(T^2/r^3\\) Mercury 0.387 0.241 1.00 Venus 0.723 0.615 1.00 Earth 1.000 1.000 1.00 Mars 1.524 1.881 1.00 Jupiter 5.203 11.86 1.00 Saturn 9.537 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.07 164.8 1.00 The \\(T^2/r^3\\) value is normalized to 1 for all planets, demonstrating that the relationship holds throughout the Solar System.","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#jupiters-moons","text":"Jupiter's four largest moons (the Galilean moons) provide another excellent example: Moon Mean Orbital Radius (km) Orbital Period (days) \\(T^2/r^3\\) (constant) Io 421,800 1.769 \\(1.77 \\times 10^{-16}\\) Europa 671,100 3.551 \\(1.77 \\times 10^{-16}\\) Ganymede 1,070,400 7.155 \\(1.77 \\times 10^{-16}\\) Callisto 1,882,700 16.69 \\(1.77 \\times 10^{-16}\\) The constant \\(T^2/r^3\\) value across all four moons confirms Kepler's Third Law and allows us to calculate Jupiter's mass.","title":"Jupiter's Moons"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extension-to-elliptical-orbits","text":"","title":"4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generalized-form-of-keplers-third-law","text":"For elliptical orbits, Kepler's Third Law still applies, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot M} \\] This means the relationship between period and semi-major axis holds regardless of the eccentricity of the orbit.","title":"Generalized Form of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-comets-and-asteroids","text":"Bodies with highly elliptical orbits, such as comets, still follow Kepler's Third Law. For example, Halley's Comet: - Orbital period: ~76 years - Semi-major axis: ~17.8 AU This relationship allows astronomers to predict when comets will return to the inner Solar System, even with very elongated orbits.","title":"Implications for Comets and Asteroids"},{"location":"1%20Physics/2%20Gravity/Problem_1/#binary-star-systems","text":"For binary star systems, where two stars orbit their common center of mass, a modified version applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot (M_1 + M_2)} \\] Where \\(M_1\\) and \\(M_2\\) are the masses of the two stars and \\(a\\) is the semi-major axis of their orbit.","title":"Binary Star Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-computational-analysis","text":"In the accompanying Python simulation, we demonstrate: Visualization of circular orbits for various orbital radii Verification of the \\(T^2 \\propto r^3\\) relationship Application to real planetary data Interactive exploration of how changing parameters affects orbital dynamics The simulation confirms that Kepler's Third Law holds across a wide range of scales, from satellite orbits around Earth to planets orbiting distant stars. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) def calculate_orbital_period(radius, central_mass): \"\"\" Calculate orbital period using Kepler's Third Law. Parameters: radius (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def generate_circular_orbit(radius, num_points=1000): \"\"\" Generate points for a circular orbit. Parameters: radius (float): Orbital radius num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y def plot_circular_orbits(radii, central_mass, planet_names=None): \"\"\" Plot multiple circular orbits with different radii. Parameters: radii (list): List of orbital radii central_mass (float): Mass of the central body planet_names (list): Optional list of names for the orbiting bodies \"\"\" plt.figure(figsize=(10, 10)) # Plot central body plt.plot(0, 0, 'yo', markersize=15, label='Central Body') # Calculate periods and plot orbits periods = [] for i, radius in enumerate(radii): x, y = generate_circular_orbit(radius) period = calculate_orbital_period(radius, central_mass) periods.append(period) name = f\"Body {i+1}\" if planet_names is None else planet_names[i] plt.plot(x, y, '--', alpha=0.6) plt.plot(x[0], y[0], 'o', markersize=8, label=f\"{name}: T = {period:.2e} s\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbits with Different Radii') plt.grid(True, alpha=0.3) plt.axis('equal') plt.legend() plt.tight_layout() plt.savefig('circular_orbits.png', dpi=300) plt.show() return radii, periods def verify_keplers_third_law(radii, periods): \"\"\" Verify Kepler's Third Law by plotting T^2 vs r^3. Parameters: radii (list): List of orbital radii periods (list): List of corresponding orbital periods \"\"\" # Calculate T^2 and r^3 t_squared = [period**2 for period in periods] r_cubed = [radius**3 for radius in radii] # Calculate the constant T^2/r^3 constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, t_squared, s=80, alpha=0.7) # Fit a line to verify the relationship coefficients = np.polyfit(r_cubed, t_squared, 1) poly = np.poly1d(coefficients) r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) plt.plot(r3_line, poly(r3_line), 'r--') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, alpha=0.3) # Add text showing the relationship plt.text(0.05, 0.9, f'T\u00b2 = {coefficients[0]:.4e} \u00d7 r\u00b3 + {coefficients[1]:.4e}', transform=plt.gca().transAxes, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) plt.tight_layout() plt.savefig('keplers_third_law_verification.png', dpi=300) plt.show() return constants def solar_system_verification(): \"\"\" Verify Kepler's Third Law using real Solar System data. \"\"\" # Solar system data (planets) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Semi-major axes in AU radii_au = [0.387, 0.723, 1.000, 1.524, 5.203, 9.537, 19.19, 30.07] # Convert AU to meters au_to_m = 1.496e11 radii_m = [r * au_to_m for r in radii_au] # Orbital periods in years periods_yr = [0.241, 0.615, 1.000, 1.881, 11.86, 29.46, 84.01, 164.8] # Convert years to seconds yr_to_s = 365.25 * 24 * 3600 periods_s = [p * yr_to_s for p in periods_yr] # Calculate T^2/r^3 for each planet (should be constant) t_squared = [p**2 for p in periods_s] r_cubed = [r**3 for r in radii_m] constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Sun's mass sun_mass = 1.989e30 # kg # Theoretical constant theoretical_constant = 4 * np.pi**2 / (G * sun_mass) # Create a table plt.figure(figsize=(12, 8)) plt.axis('off') table_data = [] table_data.append(['Planet', 'Radius (AU)', 'Period (years)', 'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)', 'Ratio to Earth']) for i, planet in enumerate(planets): # Calculate ratio of T\u00b2/r\u00b3 to Earth's value ratio = constants[i] / constants[2] # Earth is index 2 table_data.append([planet, f\"{radii_au[i]:.3f}\", f\"{periods_yr[i]:.3f}\", f\"{constants[i]:.4e}\", f\"{ratio:.6f}\"]) # Plot the table table = plt.table(cellText=table_data, loc='center', cellLoc='center', colWidths=[0.15, 0.15, 0.15, 0.22, 0.15]) table.auto_set_font_size(False) table.set_fontsize(10) table.scale(1, 1.5) plt.title(\"Verification of Kepler's Third Law in the Solar System\", y=0.8) # Add text showing the theoretical constant plt.text(0.5, 0.1, f'Theoretical value of T\u00b2/r\u00b3 = 4\u03c0\u00b2/(G\u00b7M_\u2609) = {theoretical_constant:.4e} s\u00b2/m\u00b3', horizontalalignment='center', fontsize=12, bbox=dict(facecolor='white', alpha=0.8), transform=plt.gcf().transFigure) plt.tight_layout() plt.savefig('solar_system_verification.png', dpi=300) plt.show() # Plot T^2 vs r^3 for Solar System plt.figure(figsize=(10, 6)) plt.scatter(r_cubed, t_squared, s=100, alpha=0.7) # Add planet labels for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Plot the theoretical line r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) t2_line = theoretical_constant * r3_line plt.plot(r3_line, t2_line, 'r--', label=f'T\u00b2 = {theoretical_constant:.4e} \u00d7 r\u00b3') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('Kepler\\'s Third Law for Solar System Planets') plt.grid(True, alpha=0.3) plt.legend() # Use log scale due to wide range of values plt.xscale('log') plt.yscale('log') plt.tight_layout() plt.savefig('solar_system_plot.png', dpi=300) plt.show() return planets, radii_au, periods_yr, constants def animate_orbit(radius, central_mass, num_frames=200): \"\"\" Create an animation of an orbiting body. Parameters: radius (float): Orbital radius central_mass (float): Mass of the central body num_frames (int): Number of frames in the animation Returns: FuncAnimation: Animation object \"\"\" # Calculate orbital period period = calculate_orbital_period(radius, central_mass) # Generate the orbit theta = np.linspace(0, 2*np.pi, num_frames) x = radius * np.cos(theta) y = radius * np.sin(theta) # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-radius*1.2, radius*1.2) ax.set_ylim(-radius*1.2, radius*1.2) ax.grid(True, alpha=0.3) # Plot central body ax.plot(0, 0, 'yo', markersize=15) # Plot the orbit path ax.plot(x, y, '--', alpha=0.3) # Create moving point for the orbiting body point, = ax.plot([], [], 'bo', markersize=10) # Text for displaying time time_text = ax.text(0.05, 0.95, '', transform=ax.transAxes) # Text for displaying period information ax.text(0.05, 0.90, f'Orbital period: {period:.2e} s', transform=ax.transAxes, bbox=dict(facecolor='white', alpha=0.7)) def init(): point.set_data([], []) time_text.set_text('') return point, time_text def update(frame): point.set_data(x[frame], y[frame]) time_text.set_text(f'Time: {frame/num_frames * period:.2e} s') return point, time_text ani = FuncAnimation(fig, update, frames=num_frames, init_func=init, interval=50, blit=True) plt.title(f'Orbital Motion (r = {radius:.2e} m)') plt.tight_layout() return ani def main(): \"\"\"Main function to run all simulations.\"\"\" print(\"Kepler's Third Law Simulation\") print(\"-\" * 30) # Earth-like central mass earth_mass = 5.972e24 # kg # Simulate orbits of different satellites print(\"\\n1. Simulating Earth Satellites\") satellite_radii = [7.0e6, 1.0e7, 2.0e7, 4.2e7] # Orbit radii in meters satellite_names = [\"Low Earth Orbit\", \"Mid Earth Orbit\", \"Geostationary\", \"Lunar Distance\"] radii, periods = plot_circular_orbits(satellite_radii, earth_mass, satellite_names) constants = verify_keplers_third_law(radii, periods) print(f\"Average T\u00b2/r\u00b3 constant: {np.mean(constants):.4e} s\u00b2/m\u00b3\") print(f\"Theoretical value: {4 * np.pi**2 / (G * earth_mass):.4e} s\u00b2/m\u00b3\") # Verify with Solar System data print(\"\\n2. Verifying with Solar System Data\") solar_system_verification() print(\"\\nSimulation complete! All plots have been saved.\") if __name__ == \"__main__\": main()","title":"5. Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities Motivation Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel. Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location. Mathematical Derivation and Parameters First Cosmic Velocity Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Python Implementation Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show() Graphical Representation The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Introduction This document examines the behavior of objects released from moving rockets in Earth's vicinity. Understanding these trajectories is fundamental to space mission planning, satellite deployment, and payload reentry operations. We will analyze the physics governing these motions, implement computational simulations, and visualize the resulting trajectories. Theoretical Foundation Gravitational Fundamentals The motion of a payload near Earth is primarily governed by Newton's Law of Gravitation: \\(F = G \\frac{m_1 m_2}{r^2}\\) Where: - \\(F\\) is the gravitational force between two masses - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1} \\text{ s}^{-2}\\) ) - \\(m_1\\) and \\(m_2\\) are the masses of the two objects - \\(r\\) is the distance between the centers of the masses For a payload near Earth, this simplifies to: \\(\\vec{F} = m \\cdot \\vec{g}(r)\\) Where: - \\(m\\) is the mass of the payload - \\(\\vec{g}(r)\\) is the gravitational acceleration at distance \\(r\\) from Earth's center - \\(g(r) = G \\frac{M_E}{r^2}\\) - \\(M_E\\) is Earth's mass ( \\(5.97219 \\times 10^{24} \\text{ kg}\\) ) Equations of Motion The payload's motion follows these differential equations: \\(\\frac{d^2\\vec{r}}{dt^2} = -G \\frac{M_E}{r^3} \\vec{r}\\) In Cartesian coordinates (x, y, z), these expand to: \\(\\frac{d^2x}{dt^2} = -G \\frac{M_E}{r^3} x\\) \\(\\frac{d^2y}{dt^2} = -G \\frac{M_E}{r^3} y\\) \\(\\frac{d^2z}{dt^2} = -G \\frac{M_E}{r^3} z\\) Where \\(r = \\sqrt{x^2 + y^2 + z^2}\\) Orbit Classification The trajectory type depends on the payload's specific mechanical energy: \\(\\epsilon = \\frac{v^2}{2} - \\frac{G M_E}{r}\\) This energy determines the orbit type: - \\(\\epsilon < 0\\) : Elliptical orbit (closed, payload remains bound to Earth) - \\(\\epsilon = 0\\) : Parabolic trajectory (escape with zero excess energy) - \\(\\epsilon > 0\\) : Hyperbolic trajectory (escape with excess energy) The escape velocity at distance \\(r\\) from Earth's center is: \\(v_{esc} = \\sqrt{\\frac{2 G M_E}{r}}\\) At Earth's surface ( \\(r = R_E = 6,371 \\text{ km}\\) ), this equals approximately \\(11.2 \\text{ km/s}\\) . Numerical Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_E = 5.97219e24 # Earth's mass (kg) R_E = 6371000 # Earth's radius (m) def gravitational_acceleration(t, state): \"\"\"Calculate gravitational acceleration for a given state [x, y, z, vx, vy, vz]\"\"\" x, y, z, vx, vy, vz = state r = np.sqrt(x**2 + y**2 + z**2) # Check if payload has crashed into Earth if r < R_E: return np.zeros(6) # Acceleration components ax = -G * M_E * x / r**3 ay = -G * M_E * y / r**3 az = -G * M_E * z / r**3 return np.array([vx, vy, vz, ax, ay, az]) def simulate_trajectory(initial_position, initial_velocity, t_max=10000, t_step=10): \"\"\"Simulate the trajectory of a payload with given initial conditions\"\"\" initial_state = np.concatenate((initial_position, initial_velocity)) t_span = (0, t_max) t_eval = np.arange(0, t_max, t_step) solution = solve_ivp( gravitational_acceleration, t_span, initial_state, t_eval=t_eval, method='RK45', rtol=1e-8, atol=1e-8 ) return solution def calculate_orbit_type(initial_position, initial_velocity): \"\"\"Determine orbit type based on specific energy\"\"\" r = np.linalg.norm(initial_position) v = np.linalg.norm(initial_velocity) # Calculate specific energy energy = 0.5 * v**2 - G * M_E / r # Determine orbit type if energy < -1e-8: # Small negative threshold to account for numerical precision return \"Elliptical\" elif abs(energy) < 1e-8: return \"Parabolic\" else: return \"Hyperbolic\" def plot_trajectory(solution, title=\"Payload Trajectory\"): \"\"\"Plot the 3D trajectory of the payload\"\"\" fig = plt.figure(figsize=(12, 10)) ax = fig.add_subplot(111, projection='3d') # Plot Earth u = np.linspace(0, 2*np.pi, 100) v = np.linspace(0, np.pi, 100) x = R_E * np.outer(np.cos(u), np.sin(v)) y = R_E * np.outer(np.sin(u), np.sin(v)) z = R_E * np.outer(np.ones(np.size(u)), np.cos(v)) ax.plot_surface(x, y, z, color='blue', alpha=0.2) # Plot trajectory ax.plot(solution.y[0], solution.y[1], solution.y[2], 'r-', label='Trajectory') # Mark starting point ax.scatter(solution.y[0, 0], solution.y[1, 0], solution.y[2, 0], color='green', marker='o', s=100, label='Release Point') # Calculate orbit parameters r_initial = np.sqrt(solution.y[0, 0]**2 + solution.y[1, 0]**2 + solution.y[2, 0]**2) v_initial = np.sqrt(solution.y[3, 0]**2 + solution.y[4, 0]**2 + solution.y[5, 0]**2) v_escape = np.sqrt(2 * G * M_E / r_initial) energy = 0.5 * v_initial**2 - G * M_E / r_initial # Determine orbit type if energy < -1e-8: orbit_type = \"Elliptical\" elif abs(energy) < 1e-8: orbit_type = \"Parabolic\" else: orbit_type = \"Hyperbolic\" # Add orbit information to plot info_text = ( f\"Initial altitude: {(r_initial - R_E)/1000:.1f} km\\n\" f\"Initial velocity: {v_initial/1000:.2f} km/s\\n\" f\"Escape velocity: {v_escape/1000:.2f} km/s\\n\" f\"Specific energy: {energy/1e6:.2f} MJ/kg\\n\" f\"Velocity ratio: {v_initial/v_escape:.2f} \u00d7 v_esc\" ) plt.figtext(0.15, 0.15, info_text, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) # Set plot limits max_val = max(np.max(np.abs(solution.y[0:3])), R_E * 3) ax.set_xlim([-max_val, max_val]) ax.set_ylim([-max_val, max_val]) ax.set_zlim([-max_val, max_val]) # Set labels and title ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f\"{title}\\nOrbit Type: {orbit_type}\") ax.legend(loc='upper right') plt.tight_layout() return fig, orbit_type def analyze_trajectory_types(): \"\"\"Analyze and compare different trajectory types\"\"\" altitude = R_E + 300000 # 300 km above Earth's surface # Calculate escape velocity at this altitude v_escape = np.sqrt(2 * G * M_E / altitude) print(f\"Escape velocity at {(altitude-R_E)/1000} km altitude: {v_escape/1000:.2f} km/s\") # Initial position (at altitude, along x-axis) initial_position = np.array([altitude, 0, 0]) # Different velocities for different trajectories circular_velocity = np.sqrt(G * M_E / altitude) # Velocities as fractions of escape velocity velocities = { \"Low Elliptical (0.6 v_esc)\": 0.6 * v_escape, \"High Elliptical (0.8 v_esc)\": 0.8 * v_escape, \"Near-Circular\": circular_velocity, \"Parabolic (1.0 v_esc)\": v_escape, \"Hyperbolic (1.2 v_esc)\": 1.2 * v_escape, \"Highly Hyperbolic (1.5 v_esc)\": 1.5 * v_escape } results = {} for name, v_mag in velocities.items(): # Initial velocity (perpendicular to position, in y-direction) initial_velocity = np.array([0, v_mag, 0]) # Determine simulation time based on orbit type if v_mag < v_escape: # For elliptical orbits, simulate for 1.5 orbital periods t_max = 2 * np.pi * np.sqrt(altitude**3 / (G * M_E)) * 1.5 else: # For escape trajectories, simulate long enough to see the escape path t_max = altitude * 10 / v_mag # Run simulation solution = simulate_trajectory(initial_position, initial_velocity, t_max=t_max) # Plot and save trajectory fig, orbit_type = plot_trajectory(solution, title=f\"{name} Trajectory\") fig.savefig(f\"trajectory_{name.replace(' ', '_').replace('(', '').replace(')', '')}.png\") # Calculate orbital parameters for elliptical orbits if v_mag < v_escape: # Find apogee and perigee r = np.sqrt(solution.y[0]**2 + solution.y[1]**2 + solution.y[2]**2) apogee = np.max(r) - R_E perigee = np.min(r) - R_E # Estimate orbital period v = np.sqrt(solution.y[3]**2 + solution.y[4]**2 + solution.y[5]**2) specific_energy = 0.5 * v[0]**2 - G * M_E / r[0] semi_major_axis = -G * M_E / (2 * specific_energy) period = 2 * np.pi * np.sqrt(semi_major_axis**3 / (G * M_E)) results[name] = { \"Orbit Type\": orbit_type, \"Apogee (km)\": apogee / 1000, \"Perigee (km)\": perigee / 1000, \"Period (min)\": period / 60, \"Velocity (km/s)\": v_mag / 1000 } else: results[name] = { \"Orbit Type\": orbit_type, \"Excess Velocity (km/s)\": (v_mag - v_escape) / 1000, \"Velocity (km/s)\": v_mag / 1000 } return results def simulate_reentry(initial_altitude=300000, initial_angle_deg=30, velocity_factor=0.9): \"\"\"Simulate a reentry trajectory with given parameters\"\"\" # Convert angle to radians initial_angle_rad = np.radians(initial_angle_deg) # Calculate initial position initial_position = np.array([ (R_E + initial_altitude) * np.cos(initial_angle_rad), 0, (R_E + initial_altitude) * np.sin(initial_angle_rad) ]) # Calculate escape velocity at initial position r_initial = np.linalg.norm(initial_position) v_escape = np.sqrt(2 * G * M_E / r_initial) # Set initial velocity (perpendicular to radial direction, scaled by factor) velocity_magnitude = v_escape * velocity_factor # Calculate direction perpendicular to radial direction (for orbital-like motion) radial_direction = initial_position / np.linalg.norm(initial_position) perpendicular_direction = np.array([-radial_direction[2], 0, radial_direction[0]]) perpendicular_direction = perpendicular_direction / np.linalg.norm(perpendicular_direction) # Set initial velocity initial_velocity = perpendicular_direction * velocity_magnitude # Simulate trajectory solution = simulate_trajectory(initial_position, initial_velocity) # Plot trajectory title = f\"Reentry Trajectory (Angle: {initial_angle_deg}\u00b0, Velocity: {velocity_factor:.1f}\u00d7v_esc)\" fig, orbit_type = plot_trajectory(solution, title=title) # Save figure filename = f\"reentry_angle{initial_angle_deg}_vel{velocity_factor:.1f}.png\" fig.savefig(filename) # Analyze results r = np.sqrt(solution.y[0]**2 + solution.y[1]**2 + solution.y[2]**2) min_altitude = np.min(r) - R_E reentry_results = { \"Initial Angle (degrees)\": initial_angle_deg, \"Initial Velocity (km/s)\": velocity_magnitude / 1000, \"Velocity Ratio\": velocity_factor, \"Minimum Altitude (km)\": min_altitude / 1000, \"Earth Impact\": min_altitude <= 0 } return reentry_results def run_reentry_scenarios(): \"\"\"Run multiple reentry scenarios with different parameters\"\"\" # Vary entry angles and velocities entry_angles = [5, 15, 30, 45, 60] velocity_factors = [0.7, 0.8, 0.9, 1.0, 1.1] results = {} print(\"Running reentry scenarios:\") for angle in entry_angles: for vel_factor in velocity_factors: print(f\" Angle: {angle}\u00b0, Velocity: {vel_factor:.1f}\u00d7v_esc\") key = f\"Angle {angle}\u00b0, Velocity {vel_factor:.1f}\u00d7v_esc\" results[key] = simulate_reentry( initial_altitude=300000, initial_angle_deg=angle, velocity_factor=vel_factor ) return results def main(): \"\"\"Main function to run all simulations and analyses\"\"\" print(\"=== Payload Trajectory Analysis ===\") # Analyze different trajectory types print(\"\\nAnalyzing different trajectory types...\") trajectory_results = analyze_trajectory_types() # Print trajectory results print(\"\\nTrajectory Analysis Results:\") for name, data in trajectory_results.items(): print(f\"\\n{name}:\") for key, value in data.items(): if isinstance(value, float): print(f\" {key}: {value:.2f}\") else: print(f\" {key}: {value}\") # Analyze reentry scenarios print(\"\\nAnalyzing reentry scenarios...\") reentry_results = run_reentry_scenarios() # Print reentry results print(\"\\nReentry Analysis Results:\") for name, data in reentry_results.items(): print(f\"\\n{name}:\") for key, value in data.items(): if isinstance(value, float): print(f\" {key}: {value:.2f}\") else: print(f\" {key}: {value}\") print(\"\\nSimulation complete. All trajectory visualizations have been saved.\") if __name__ == \"__main__\": main() === Payload Trajectory Analysis === Analyzing different trajectory types... Escape velocity at 300.0 km altitude: 10.93 km/s Trajectory Analysis Results: Low Elliptical (0.6 v_esc): Orbit Type: Elliptical Apogee (km): 300.00 Perigee (km): -0.00 Period (min): 62.41 Velocity (km/s): 6.56 High Elliptical (0.8 v_esc): Orbit Type: Elliptical Apogee (km): 5488.55 Perigee (km): 300.00 Period (min): 147.93 Velocity (km/s): 8.75 Near-Circular: Orbit Type: Elliptical Apogee (km): 300.00 Perigee (km): 300.00 Period (min): 90.37 Velocity (km/s): 7.73 Parabolic (1.0 v_esc): Orbit Type: Parabolic Excess Velocity (km/s): 0.00 Velocity (km/s): 10.93 Hyperbolic (1.2 v_esc): Orbit Type: Hyperbolic Excess Velocity (km/s): 2.19 Velocity (km/s): 13.12 Highly Hyperbolic (1.5 v_esc): Orbit Type: Hyperbolic Excess Velocity (km/s): 5.47 Velocity (km/s): 16.40 Trajectory Types Analysis Our simulation models three primary trajectory types that a released payload may follow: 1. Elliptical Orbits (v < v_esc) When the payload's velocity is less than escape velocity, it follows an elliptical path around Earth. The characteristics of this orbit depend on: Initial velocity magnitude : Determines the orbit's eccentricity Initial velocity direction : Affects the orbit's orientation Release altitude : Influences the orbit's size The specific parameters of elliptical orbits include: \\(a = \\frac{r_1 r_2}{r_1 + r_2}\\) \\(e = \\frac{r_a - r_p}{r_a + r_p}\\) \\(T = 2\\pi\\sqrt{\\frac{a^3}{GM_E}}\\) Where: - \\(a\\) is the semi-major axis - \\(e\\) is the eccentricity - \\(r_a\\) is the apogee distance (furthest point) - \\(r_p\\) is the perigee distance (closest point) - \\(T\\) is the orbital period 2. Parabolic Trajectories (v = v_esc) At exactly escape velocity, the payload follows a parabolic trajectory where: - The payload has zero excess energy - It will never return to Earth - Its velocity approaches zero as distance approaches infinity 3. Hyperbolic Trajectories (v > v_esc) With velocities exceeding escape velocity, the payload follows a hyperbolic path: - The payload has positive excess energy - The trajectory has asymptotic behavior at large distances - Higher velocities result in smaller deflection angles Applications to Space Missions Orbital Insertion To place a payload into a specific orbit requires precise velocity control. The simulation demonstrates that: Velocities near \\(v_c = \\sqrt{\\frac{GM_E}{r}}\\) produce nearly circular orbits Velocities between \\(0.6v_{esc}\\) and \\(0.9v_{esc}\\) create elliptical orbits with varying eccentricities The direction of the velocity vector determines the orbit's orientation For mission planning, this means: - Payloads released with insufficient velocity will impact Earth - Excessive velocity wastes fuel or results in escape trajectories - Precise timing and orientation are critical for desired orbital parameters Reentry Scenarios For payloads returning to Earth, key factors include: Entry angle : Critical for managing thermal loads and deceleration Shallow angles (<5\u00b0) risk atmospheric skip-out Steep angles (>60\u00b0) create excessive heating and g-forces Optimal angles typically range from 20\u00b0 to 45\u00b0 Entry velocity : Affects heating rate and deceleration profile Higher velocities require more robust thermal protection Typical reentry velocities for Earth return are 7-12 km/s Our simulations show that successful reentry requires balancing these parameters within specific ranges to ensure both atmospheric capture and survivable deceleration rates. Escape Trajectories For interplanetary missions, payloads must exceed escape velocity. The trajectory analysis shows: At \\(v = 1.1v_{esc}\\) , the payload escapes with minimal excess energy At \\(v = 1.5v_{esc}\\) or higher, the trajectory is nearly straight with minimal deflection The excess velocity ( \\(v - v_{esc}\\) ) determines the payload's speed at great distances from Earth This has implications for: - Interplanetary transfer orbits - Gravity assist maneuvers - Mission delta-v requirements Visualization Results The simulation generates visual representations of different trajectories, clearly showing: Elliptical orbits with varying eccentricities Parabolic escape trajectories Hyperbolic escape paths Reentry trajectories with different entry angles and velocities These visualizations provide intuitive understanding of how initial conditions affect the payload's path, supporting mission planning and educational purposes. Conclusion The trajectory of a payload released near Earth depends primarily on its initial velocity relative to escape velocity at its release position. Our numerical analysis demonstrates how small changes in initial conditions can dramatically alter a payload's path, highlighting the importance of precise calculations in space mission planning. Through this simulation and analysis, we gain insights into: - The fundamental physics governing orbital motion - The relationship between initial conditions and resulting trajectories - Practical considerations for satellite deployment, orbital insertion, and reentry operations This computational approach bridges theoretical orbital mechanics with practical space mission applications, providing a valuable tool for education, mission planning, and trajectory analysis.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"This document examines the behavior of objects released from moving rockets in Earth's vicinity. Understanding these trajectories is fundamental to space mission planning, satellite deployment, and payload reentry operations. We will analyze the physics governing these motions, implement computational simulations, and visualize the resulting trajectories.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-fundamentals","text":"The motion of a payload near Earth is primarily governed by Newton's Law of Gravitation: \\(F = G \\frac{m_1 m_2}{r^2}\\) Where: - \\(F\\) is the gravitational force between two masses - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1} \\text{ s}^{-2}\\) ) - \\(m_1\\) and \\(m_2\\) are the masses of the two objects - \\(r\\) is the distance between the centers of the masses For a payload near Earth, this simplifies to: \\(\\vec{F} = m \\cdot \\vec{g}(r)\\) Where: - \\(m\\) is the mass of the payload - \\(\\vec{g}(r)\\) is the gravitational acceleration at distance \\(r\\) from Earth's center - \\(g(r) = G \\frac{M_E}{r^2}\\) - \\(M_E\\) is Earth's mass ( \\(5.97219 \\times 10^{24} \\text{ kg}\\) )","title":"Gravitational Fundamentals"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The payload's motion follows these differential equations: \\(\\frac{d^2\\vec{r}}{dt^2} = -G \\frac{M_E}{r^3} \\vec{r}\\) In Cartesian coordinates (x, y, z), these expand to: \\(\\frac{d^2x}{dt^2} = -G \\frac{M_E}{r^3} x\\) \\(\\frac{d^2y}{dt^2} = -G \\frac{M_E}{r^3} y\\) \\(\\frac{d^2z}{dt^2} = -G \\frac{M_E}{r^3} z\\) Where \\(r = \\sqrt{x^2 + y^2 + z^2}\\)","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbit-classification","text":"The trajectory type depends on the payload's specific mechanical energy: \\(\\epsilon = \\frac{v^2}{2} - \\frac{G M_E}{r}\\) This energy determines the orbit type: - \\(\\epsilon < 0\\) : Elliptical orbit (closed, payload remains bound to Earth) - \\(\\epsilon = 0\\) : Parabolic trajectory (escape with zero excess energy) - \\(\\epsilon > 0\\) : Hyperbolic trajectory (escape with excess energy) The escape velocity at distance \\(r\\) from Earth's center is: \\(v_{esc} = \\sqrt{\\frac{2 G M_E}{r}}\\) At Earth's surface ( \\(r = R_E = 6,371 \\text{ km}\\) ), this equals approximately \\(11.2 \\text{ km/s}\\) .","title":"Orbit Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_E = 5.97219e24 # Earth's mass (kg) R_E = 6371000 # Earth's radius (m) def gravitational_acceleration(t, state): \"\"\"Calculate gravitational acceleration for a given state [x, y, z, vx, vy, vz]\"\"\" x, y, z, vx, vy, vz = state r = np.sqrt(x**2 + y**2 + z**2) # Check if payload has crashed into Earth if r < R_E: return np.zeros(6) # Acceleration components ax = -G * M_E * x / r**3 ay = -G * M_E * y / r**3 az = -G * M_E * z / r**3 return np.array([vx, vy, vz, ax, ay, az]) def simulate_trajectory(initial_position, initial_velocity, t_max=10000, t_step=10): \"\"\"Simulate the trajectory of a payload with given initial conditions\"\"\" initial_state = np.concatenate((initial_position, initial_velocity)) t_span = (0, t_max) t_eval = np.arange(0, t_max, t_step) solution = solve_ivp( gravitational_acceleration, t_span, initial_state, t_eval=t_eval, method='RK45', rtol=1e-8, atol=1e-8 ) return solution def calculate_orbit_type(initial_position, initial_velocity): \"\"\"Determine orbit type based on specific energy\"\"\" r = np.linalg.norm(initial_position) v = np.linalg.norm(initial_velocity) # Calculate specific energy energy = 0.5 * v**2 - G * M_E / r # Determine orbit type if energy < -1e-8: # Small negative threshold to account for numerical precision return \"Elliptical\" elif abs(energy) < 1e-8: return \"Parabolic\" else: return \"Hyperbolic\" def plot_trajectory(solution, title=\"Payload Trajectory\"): \"\"\"Plot the 3D trajectory of the payload\"\"\" fig = plt.figure(figsize=(12, 10)) ax = fig.add_subplot(111, projection='3d') # Plot Earth u = np.linspace(0, 2*np.pi, 100) v = np.linspace(0, np.pi, 100) x = R_E * np.outer(np.cos(u), np.sin(v)) y = R_E * np.outer(np.sin(u), np.sin(v)) z = R_E * np.outer(np.ones(np.size(u)), np.cos(v)) ax.plot_surface(x, y, z, color='blue', alpha=0.2) # Plot trajectory ax.plot(solution.y[0], solution.y[1], solution.y[2], 'r-', label='Trajectory') # Mark starting point ax.scatter(solution.y[0, 0], solution.y[1, 0], solution.y[2, 0], color='green', marker='o', s=100, label='Release Point') # Calculate orbit parameters r_initial = np.sqrt(solution.y[0, 0]**2 + solution.y[1, 0]**2 + solution.y[2, 0]**2) v_initial = np.sqrt(solution.y[3, 0]**2 + solution.y[4, 0]**2 + solution.y[5, 0]**2) v_escape = np.sqrt(2 * G * M_E / r_initial) energy = 0.5 * v_initial**2 - G * M_E / r_initial # Determine orbit type if energy < -1e-8: orbit_type = \"Elliptical\" elif abs(energy) < 1e-8: orbit_type = \"Parabolic\" else: orbit_type = \"Hyperbolic\" # Add orbit information to plot info_text = ( f\"Initial altitude: {(r_initial - R_E)/1000:.1f} km\\n\" f\"Initial velocity: {v_initial/1000:.2f} km/s\\n\" f\"Escape velocity: {v_escape/1000:.2f} km/s\\n\" f\"Specific energy: {energy/1e6:.2f} MJ/kg\\n\" f\"Velocity ratio: {v_initial/v_escape:.2f} \u00d7 v_esc\" ) plt.figtext(0.15, 0.15, info_text, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) # Set plot limits max_val = max(np.max(np.abs(solution.y[0:3])), R_E * 3) ax.set_xlim([-max_val, max_val]) ax.set_ylim([-max_val, max_val]) ax.set_zlim([-max_val, max_val]) # Set labels and title ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f\"{title}\\nOrbit Type: {orbit_type}\") ax.legend(loc='upper right') plt.tight_layout() return fig, orbit_type def analyze_trajectory_types(): \"\"\"Analyze and compare different trajectory types\"\"\" altitude = R_E + 300000 # 300 km above Earth's surface # Calculate escape velocity at this altitude v_escape = np.sqrt(2 * G * M_E / altitude) print(f\"Escape velocity at {(altitude-R_E)/1000} km altitude: {v_escape/1000:.2f} km/s\") # Initial position (at altitude, along x-axis) initial_position = np.array([altitude, 0, 0]) # Different velocities for different trajectories circular_velocity = np.sqrt(G * M_E / altitude) # Velocities as fractions of escape velocity velocities = { \"Low Elliptical (0.6 v_esc)\": 0.6 * v_escape, \"High Elliptical (0.8 v_esc)\": 0.8 * v_escape, \"Near-Circular\": circular_velocity, \"Parabolic (1.0 v_esc)\": v_escape, \"Hyperbolic (1.2 v_esc)\": 1.2 * v_escape, \"Highly Hyperbolic (1.5 v_esc)\": 1.5 * v_escape } results = {} for name, v_mag in velocities.items(): # Initial velocity (perpendicular to position, in y-direction) initial_velocity = np.array([0, v_mag, 0]) # Determine simulation time based on orbit type if v_mag < v_escape: # For elliptical orbits, simulate for 1.5 orbital periods t_max = 2 * np.pi * np.sqrt(altitude**3 / (G * M_E)) * 1.5 else: # For escape trajectories, simulate long enough to see the escape path t_max = altitude * 10 / v_mag # Run simulation solution = simulate_trajectory(initial_position, initial_velocity, t_max=t_max) # Plot and save trajectory fig, orbit_type = plot_trajectory(solution, title=f\"{name} Trajectory\") fig.savefig(f\"trajectory_{name.replace(' ', '_').replace('(', '').replace(')', '')}.png\") # Calculate orbital parameters for elliptical orbits if v_mag < v_escape: # Find apogee and perigee r = np.sqrt(solution.y[0]**2 + solution.y[1]**2 + solution.y[2]**2) apogee = np.max(r) - R_E perigee = np.min(r) - R_E # Estimate orbital period v = np.sqrt(solution.y[3]**2 + solution.y[4]**2 + solution.y[5]**2) specific_energy = 0.5 * v[0]**2 - G * M_E / r[0] semi_major_axis = -G * M_E / (2 * specific_energy) period = 2 * np.pi * np.sqrt(semi_major_axis**3 / (G * M_E)) results[name] = { \"Orbit Type\": orbit_type, \"Apogee (km)\": apogee / 1000, \"Perigee (km)\": perigee / 1000, \"Period (min)\": period / 60, \"Velocity (km/s)\": v_mag / 1000 } else: results[name] = { \"Orbit Type\": orbit_type, \"Excess Velocity (km/s)\": (v_mag - v_escape) / 1000, \"Velocity (km/s)\": v_mag / 1000 } return results def simulate_reentry(initial_altitude=300000, initial_angle_deg=30, velocity_factor=0.9): \"\"\"Simulate a reentry trajectory with given parameters\"\"\" # Convert angle to radians initial_angle_rad = np.radians(initial_angle_deg) # Calculate initial position initial_position = np.array([ (R_E + initial_altitude) * np.cos(initial_angle_rad), 0, (R_E + initial_altitude) * np.sin(initial_angle_rad) ]) # Calculate escape velocity at initial position r_initial = np.linalg.norm(initial_position) v_escape = np.sqrt(2 * G * M_E / r_initial) # Set initial velocity (perpendicular to radial direction, scaled by factor) velocity_magnitude = v_escape * velocity_factor # Calculate direction perpendicular to radial direction (for orbital-like motion) radial_direction = initial_position / np.linalg.norm(initial_position) perpendicular_direction = np.array([-radial_direction[2], 0, radial_direction[0]]) perpendicular_direction = perpendicular_direction / np.linalg.norm(perpendicular_direction) # Set initial velocity initial_velocity = perpendicular_direction * velocity_magnitude # Simulate trajectory solution = simulate_trajectory(initial_position, initial_velocity) # Plot trajectory title = f\"Reentry Trajectory (Angle: {initial_angle_deg}\u00b0, Velocity: {velocity_factor:.1f}\u00d7v_esc)\" fig, orbit_type = plot_trajectory(solution, title=title) # Save figure filename = f\"reentry_angle{initial_angle_deg}_vel{velocity_factor:.1f}.png\" fig.savefig(filename) # Analyze results r = np.sqrt(solution.y[0]**2 + solution.y[1]**2 + solution.y[2]**2) min_altitude = np.min(r) - R_E reentry_results = { \"Initial Angle (degrees)\": initial_angle_deg, \"Initial Velocity (km/s)\": velocity_magnitude / 1000, \"Velocity Ratio\": velocity_factor, \"Minimum Altitude (km)\": min_altitude / 1000, \"Earth Impact\": min_altitude <= 0 } return reentry_results def run_reentry_scenarios(): \"\"\"Run multiple reentry scenarios with different parameters\"\"\" # Vary entry angles and velocities entry_angles = [5, 15, 30, 45, 60] velocity_factors = [0.7, 0.8, 0.9, 1.0, 1.1] results = {} print(\"Running reentry scenarios:\") for angle in entry_angles: for vel_factor in velocity_factors: print(f\" Angle: {angle}\u00b0, Velocity: {vel_factor:.1f}\u00d7v_esc\") key = f\"Angle {angle}\u00b0, Velocity {vel_factor:.1f}\u00d7v_esc\" results[key] = simulate_reentry( initial_altitude=300000, initial_angle_deg=angle, velocity_factor=vel_factor ) return results def main(): \"\"\"Main function to run all simulations and analyses\"\"\" print(\"=== Payload Trajectory Analysis ===\") # Analyze different trajectory types print(\"\\nAnalyzing different trajectory types...\") trajectory_results = analyze_trajectory_types() # Print trajectory results print(\"\\nTrajectory Analysis Results:\") for name, data in trajectory_results.items(): print(f\"\\n{name}:\") for key, value in data.items(): if isinstance(value, float): print(f\" {key}: {value:.2f}\") else: print(f\" {key}: {value}\") # Analyze reentry scenarios print(\"\\nAnalyzing reentry scenarios...\") reentry_results = run_reentry_scenarios() # Print reentry results print(\"\\nReentry Analysis Results:\") for name, data in reentry_results.items(): print(f\"\\n{name}:\") for key, value in data.items(): if isinstance(value, float): print(f\" {key}: {value:.2f}\") else: print(f\" {key}: {value}\") print(\"\\nSimulation complete. All trajectory visualizations have been saved.\") if __name__ == \"__main__\": main() === Payload Trajectory Analysis === Analyzing different trajectory types... Escape velocity at 300.0 km altitude: 10.93 km/s Trajectory Analysis Results: Low Elliptical (0.6 v_esc): Orbit Type: Elliptical Apogee (km): 300.00 Perigee (km): -0.00 Period (min): 62.41 Velocity (km/s): 6.56 High Elliptical (0.8 v_esc): Orbit Type: Elliptical Apogee (km): 5488.55 Perigee (km): 300.00 Period (min): 147.93 Velocity (km/s): 8.75 Near-Circular: Orbit Type: Elliptical Apogee (km): 300.00 Perigee (km): 300.00 Period (min): 90.37 Velocity (km/s): 7.73 Parabolic (1.0 v_esc): Orbit Type: Parabolic Excess Velocity (km/s): 0.00 Velocity (km/s): 10.93 Hyperbolic (1.2 v_esc): Orbit Type: Hyperbolic Excess Velocity (km/s): 2.19 Velocity (km/s): 13.12 Highly Hyperbolic (1.5 v_esc): Orbit Type: Hyperbolic Excess Velocity (km/s): 5.47 Velocity (km/s): 16.40","title":"Numerical Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-analysis","text":"Our simulation models three primary trajectory types that a released payload may follow:","title":"Trajectory Types Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-elliptical-orbits-v-v_esc","text":"When the payload's velocity is less than escape velocity, it follows an elliptical path around Earth. The characteristics of this orbit depend on: Initial velocity magnitude : Determines the orbit's eccentricity Initial velocity direction : Affects the orbit's orientation Release altitude : Influences the orbit's size The specific parameters of elliptical orbits include: \\(a = \\frac{r_1 r_2}{r_1 + r_2}\\) \\(e = \\frac{r_a - r_p}{r_a + r_p}\\) \\(T = 2\\pi\\sqrt{\\frac{a^3}{GM_E}}\\) Where: - \\(a\\) is the semi-major axis - \\(e\\) is the eccentricity - \\(r_a\\) is the apogee distance (furthest point) - \\(r_p\\) is the perigee distance (closest point) - \\(T\\) is the orbital period","title":"1. Elliptical Orbits (v &lt; v_esc)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-parabolic-trajectories-v-v_esc","text":"At exactly escape velocity, the payload follows a parabolic trajectory where: - The payload has zero excess energy - It will never return to Earth - Its velocity approaches zero as distance approaches infinity","title":"2. Parabolic Trajectories (v = v_esc)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-hyperbolic-trajectories-v-v_esc","text":"With velocities exceeding escape velocity, the payload follows a hyperbolic path: - The payload has positive excess energy - The trajectory has asymptotic behavior at large distances - Higher velocities result in smaller deflection angles","title":"3. Hyperbolic Trajectories (v &gt; v_esc)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-to-space-missions","text":"","title":"Applications to Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion","text":"To place a payload into a specific orbit requires precise velocity control. The simulation demonstrates that: Velocities near \\(v_c = \\sqrt{\\frac{GM_E}{r}}\\) produce nearly circular orbits Velocities between \\(0.6v_{esc}\\) and \\(0.9v_{esc}\\) create elliptical orbits with varying eccentricities The direction of the velocity vector determines the orbit's orientation For mission planning, this means: - Payloads released with insufficient velocity will impact Earth - Excessive velocity wastes fuel or results in escape trajectories - Precise timing and orientation are critical for desired orbital parameters","title":"Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry-scenarios","text":"For payloads returning to Earth, key factors include: Entry angle : Critical for managing thermal loads and deceleration Shallow angles (<5\u00b0) risk atmospheric skip-out Steep angles (>60\u00b0) create excessive heating and g-forces Optimal angles typically range from 20\u00b0 to 45\u00b0 Entry velocity : Affects heating rate and deceleration profile Higher velocities require more robust thermal protection Typical reentry velocities for Earth return are 7-12 km/s Our simulations show that successful reentry requires balancing these parameters within specific ranges to ensure both atmospheric capture and survivable deceleration rates.","title":"Reentry Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-trajectories","text":"For interplanetary missions, payloads must exceed escape velocity. The trajectory analysis shows: At \\(v = 1.1v_{esc}\\) , the payload escapes with minimal excess energy At \\(v = 1.5v_{esc}\\) or higher, the trajectory is nearly straight with minimal deflection The excess velocity ( \\(v - v_{esc}\\) ) determines the payload's speed at great distances from Earth This has implications for: - Interplanetary transfer orbits - Gravity assist maneuvers - Mission delta-v requirements","title":"Escape Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization-results","text":"The simulation generates visual representations of different trajectories, clearly showing: Elliptical orbits with varying eccentricities Parabolic escape trajectories Hyperbolic escape paths Reentry trajectories with different entry angles and velocities These visualizations provide intuitive understanding of how initial conditions affect the payload's path, supporting mission planning and educational purposes.","title":"Visualization Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"The trajectory of a payload released near Earth depends primarily on its initial velocity relative to escape velocity at its release position. Our numerical analysis demonstrates how small changes in initial conditions can dramatically alter a payload's path, highlighting the importance of precise calculations in space mission planning. Through this simulation and analysis, we gain insights into: - The fundamental physics governing orbital motion - The relationship between initial conditions and resulting trajectories - Practical considerations for satellite deployment, orbital insertion, and reentry operations This computational approach bridges theoretical orbital mechanics with practical space mission applications, providing a valuable tool for education, mission planning, and trajectory analysis.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Introduction This document examines the phenomenon of wave interference on a water surface, specifically focusing on patterns created when multiple coherent wave sources are arranged at the vertices of a regular polygon. Understanding these patterns provides insight into fundamental wave behavior and the principle of superposition. Theoretical Foundation Wave Propagation from a Point Source A circular wave on the water surface emanating from a point source located at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\(\\eta(x,y,t) = \\frac{A}{r} \\cdot \\cos(kr - \\omega t + \\phi)\\) Where: - \\(\\eta(x,y,t)\\) is the displacement of the water surface at point \\((x,y)\\) and time \\(t\\) - \\(A\\) is the amplitude of the wave - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) - \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) - \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) - \\(\\phi\\) is the initial phase Principle of Superposition When multiple waves overlap, the resulting displacement at any point is the sum of the individual wave displacements. For \\(N\\) wave sources, the total displacement is: \\(\\eta_{sum}(x,y,t) = \\sum_{i=1}^{N} \\eta_i(x,y,t)\\) The resulting interference pattern can be characterized by regions of: - Constructive interference : Where waves reinforce each other, creating larger amplitudes - Destructive interference : Where waves cancel each other, resulting in reduced or zero amplitude Numerical Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from matplotlib import cm from mpl_toolkits.mplot3d import Axes3D def create_polygon_vertices(n_sides, radius=1.0, center=(0, 0)): \"\"\" Generate vertices of a regular polygon. Parameters: ----------- n_sides : int Number of sides in the regular polygon radius : float, optional Distance from center to each vertex center : tuple, optional (x, y) coordinates of the polygon center Returns: -------- vertices : numpy.ndarray Array of vertex coordinates with shape (n_sides, 2) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) vertices = np.zeros((n_sides, 2)) for i, angle in enumerate(angles): vertices[i, 0] = center[0] + radius * np.cos(angle) vertices[i, 1] = center[1] + radius * np.sin(angle) return vertices def wave_displacement(x, y, source_x, source_y, amplitude, k, omega, t, phase=0): \"\"\" Calculate wave displacement at point (x, y) from a source at (source_x, source_y). Parameters: ----------- x, y : float or numpy.ndarray Coordinates where displacement is calculated source_x, source_y : float Coordinates of the wave source amplitude : float Wave amplitude k : float Wave number (2\u03c0/\u03bb) omega : float Angular frequency (2\u03c0f) t : float Time phase : float, optional Initial phase of the wave Returns: -------- displacement : float or numpy.ndarray Wave displacement at point (x, y) \"\"\" r = np.sqrt((x - source_x)**2 + (y - source_y)**2) # Add small constant to avoid division by zero r = np.maximum(r, 1e-10) return amplitude / np.sqrt(r) * np.cos(k * r - omega * t + phase) def calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, t): \"\"\" Calculate interference pattern from multiple sources. Parameters: ----------- x_grid, y_grid : numpy.ndarray Meshgrid of x and y coordinates sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) amplitude : float Wave amplitude k : float Wave number (2\u03c0/\u03bb) omega : float Angular frequency (2\u03c0f) t : float Time Returns: -------- total_displacement : numpy.ndarray Total wave displacement at each point in the grid \"\"\" total_displacement = np.zeros_like(x_grid) for i in range(len(sources)): source_x, source_y = sources[i] # Calculate phase based on source index for variety phase = i * 2 * np.pi / len(sources) displacement = wave_displacement(x_grid, y_grid, source_x, source_y, amplitude, k, omega, t, phase) total_displacement += displacement return total_displacement def plot_interference_pattern(sources, size=10, resolution=500, amplitude=1.0, wavelength=1.0, frequency=1.0, time=0, plot_3d=False): \"\"\" Plot interference pattern from sources at a given time. Parameters: ----------- sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) size : float, optional Size of the plotting domain resolution : int, optional Grid resolution amplitude : float, optional Wave amplitude wavelength : float, optional Wavelength of the waves frequency : float, optional Frequency of the waves time : float, optional Time at which to calculate the interference pattern plot_3d : bool, optional Whether to create a 3D surface plot Returns: -------- fig : matplotlib.figure.Figure The created figure \"\"\" # Calculate wave parameters k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create grid x = np.linspace(-size/2, size/2, resolution) y = np.linspace(-size/2, size/2, resolution) x_grid, y_grid = np.meshgrid(x, y) # Calculate interference pattern z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, time) if plot_3d: # 3D surface plot fig = plt.figure(figsize=(12, 10)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(x_grid, y_grid, z_grid, cmap=cm.coolwarm, linewidth=0, antialiased=True) ax.set_zlim(-amplitude * 3, amplitude * 3) ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Wave height') fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5) else: # 2D color map fig, ax = plt.subplots(figsize=(10, 8)) im = ax.imshow(z_grid, extent=[-size/2, size/2, -size/2, size/2], origin='lower', cmap='coolwarm') # Plot source locations for source in sources: ax.plot(source[0], source[1], 'ko', markersize=8) # Customize plot ax.set_xlabel('X position') ax.set_ylabel('Y position') plt.title(f'Wave Interference Pattern at t={time:.2f}s') fig.colorbar(im, ax=ax) return fig def animate_interference(sources, size=10, resolution=200, amplitude=1.0, wavelength=1.0, frequency=1.0, duration=5.0, fps=30): \"\"\" Create animation of evolving interference pattern. Parameters: ----------- sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) size : float, optional Size of the plotting domain resolution : int, optional Grid resolution amplitude : float, optional Wave amplitude wavelength : float, optional Wavelength of the waves frequency : float, optional Frequency of the waves duration : float, optional Duration of the animation in seconds fps : int, optional Frames per second Returns: -------- anim : matplotlib.animation.FuncAnimation Animation object \"\"\" # Calculate wave parameters k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create grid x = np.linspace(-size/2, size/2, resolution) y = np.linspace(-size/2, size/2, resolution) x_grid, y_grid = np.meshgrid(x, y) # Setup figure for animation fig, ax = plt.subplots(figsize=(10, 8)) # Initial frame z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, 0) im = ax.imshow(z_grid, extent=[-size/2, size/2, -size/2, size/2], origin='lower', cmap='coolwarm', animated=True) # Plot source locations for source in sources: ax.plot(source[0], source[1], 'ko', markersize=8) # Customize plot ax.set_xlabel('X position') ax.set_ylabel('Y position') title = ax.set_title('Wave Interference Pattern at t=0.00s') fig.colorbar(im, ax=ax) def update(frame): \"\"\"Update function for animation.\"\"\" time = frame / fps z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, time) im.set_array(z_grid) title.set_text(f'Wave Interference Pattern at t={time:.2f}s') return im, title frames = int(duration * fps) anim = FuncAnimation(fig, update, frames=frames, interval=1000/fps, blit=True) return anim def analyze_regular_polygon(n_sides, radius=5.0, size=20, wavelength=2.0, save_animation=False, save_pattern=False): \"\"\" Analyze interference pattern for a regular polygon arrangement of sources. Parameters: ----------- n_sides : int Number of sides of the regular polygon radius : float, optional Radius of the polygon size : float, optional Size of the plotting domain wavelength : float, optional Wavelength of the waves save_animation : bool, optional Whether to save the animation save_pattern : bool, optional Whether to save the static pattern image Returns: -------- None \"\"\" # Create sources at polygon vertices sources = create_polygon_vertices(n_sides, radius) # Plot initial interference pattern fig_2d = plot_interference_pattern(sources, size=size, wavelength=wavelength, time=0) plt.tight_layout() if save_pattern: plt.savefig(f\"{n_sides}_sided_polygon_interference.png\", dpi=300) plt.figure() # Create 3D visualization fig_3d = plot_interference_pattern(sources, size=size, resolution=200, wavelength=wavelength, time=0, plot_3d=True) plt.tight_layout() if save_pattern: plt.savefig(f\"{n_sides}_sided_polygon_interference_3d.png\", dpi=300) # Create animation anim = animate_interference(sources, size=size, wavelength=wavelength, duration=5.0, fps=15) if save_animation: anim.save(f\"{n_sides}_sided_polygon_interference.mp4\", writer='ffmpeg', fps=15, dpi=200) plt.show() # Print analysis print(f\"Analysis of {n_sides}-sided regular polygon:\") print(f\"- {n_sides} coherent sources placed at vertices of a regular polygon\") print(f\"- Distance between adjacent sources: {2 * radius * np.sin(np.pi/n_sides):.2f} units\") print(f\"- Wavelength: {wavelength} units\") # Calculate central interference center_x, center_y = 0, 0 k = 2 * np.pi / wavelength omega = 2 * np.pi # frequency = 1 by default time = 0 # Check interference at center center_displacement = calculate_interference(center_x, center_y, sources, 1.0, k, omega, time) if abs(center_displacement) > 0.8 * n_sides: print(\"- Center shows strong constructive interference\") elif abs(center_displacement) < 0.2 * n_sides: print(\"- Center shows strong destructive interference\") else: print(\"- Center shows partial interference\") def main(): \"\"\"Run analyses for different regular polygons.\"\"\" # Analyze triangle (3 sides) analyze_regular_polygon(3, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Analyze square (4 sides) analyze_regular_polygon(4, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Analyze pentagon (5 sides) analyze_regular_polygon(5, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Optional: Analyze hexagon (6 sides) analyze_regular_polygon(6, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) if __name__ == \"__main__\": main() Analysis of Interference Patterns Triangle (3-Source) Interference When three coherent wave sources are placed at the vertices of an equilateral triangle, several distinctive interference patterns emerge: Radial Symmetry : The overall pattern displays three-fold radial symmetry, reflecting the geometric arrangement of the sources. Nodal Lines : Clear nodal lines (regions of destructive interference) form between the sources, creating a pattern resembling a distorted star. Central Interference : The interference at the center of the triangle depends on the relationship between the wavelength and the side length of the triangle: When the distance between sources is an integer multiple of wavelength: Constructive interference When the distance is an odd multiple of half-wavelengths: Destructive interference Time Evolution : As time progresses, the pattern appears to rotate while maintaining its overall structure, creating a dynamic visual display of wave interaction. Mathematical Analysis of Interference Conditions For sources arranged in a regular polygon with \\(N\\) sides and radius \\(R\\) , we can derive the conditions for constructive and destructive interference at various points. For a point at position \\((x, y)\\) , the path difference \\(\\Delta r_i\\) between waves from adjacent sources is: \\(\\Delta r_i = |\\vec{r}_i - \\vec{r}_{i+1}|\\) where \\(\\vec{r}_i\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Constructive Interference Condition : \\(\\Delta r_i = m\\lambda\\) , where \\(m\\) is an integer Destructive Interference Condition : \\(\\Delta r_i = (m+\\frac{1}{2})\\lambda\\) , where \\(m\\) is an integer At the center of the polygon (origin), all sources are equidistant, so: - For even values of \\(N\\) : Adjacent sources are in phase opposition when the polygon radius is an odd multiple of quarter-wavelengths, leading to destructive interference - For odd values of \\(N\\) : Complete destructive interference cannot occur at the center Square (4-Source) Interference The square arrangement of sources produces: Four-fold Symmetry : The interference pattern shows clear four-fold symmetry. Checkerboard Pattern : In the central region, alternating regions of constructive and destructive interference create a checkerboard-like pattern. Diagonal Enhancement : Strong constructive interference appears along the diagonals of the square when the diagonal length is appropriately related to the wavelength. Strong Central Interference : The center typically exhibits pronounced interference effects, with the nature (constructive or destructive) depending on the relationship between the square side length and the wavelength. Pentagon and Higher-Order Polygons As the number of sides increases: Increasing Circular Symmetry : The interference pattern begins to approximate circular symmetry, especially at distances far from the sources. Complex Near-field Patterns : Close to the sources, intricate interference patterns form with the same symmetry as the polygon. Central Enhancement : With odd numbers of sides, the center tends to show constructive interference under a wider range of conditions than with even-sided polygons. Applications and Extensions The study of interference patterns from regularly spaced sources has numerous applications: Phased Array Systems : Used in radar, sonar, and communications to direct signals through constructive interference. Antenna Design : Multiple antennas arranged in specific geometric patterns can enhance signal strength in desired directions. Acoustic Engineering : Understanding multi-source interference helps in designing concert halls and speaker systems. Optical Phenomena : Similar principles govern multiple-slit diffraction and interference in optics. Extensions to this study could include: - Varying the amplitude or phase of individual sources - Introducing time delays between sources - Considering non-uniform mediums where wave speed varies with position Conclusion The interference patterns created by waves from sources arranged in regular polygons demonstrate the rich behavior emerging from the superposition principle. These patterns exhibit symmetry reflecting the source arrangement and create regions of enhanced and diminished wave amplitude based on the phase relationships between overlapping waves. Through numerical simulation, we can visualize these complex patterns and understand the conditions that lead to constructive and destructive interference. This analysis provides insight into fundamental wave behavior with applications across multiple fields of physics and engineering.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"This document examines the phenomenon of wave interference on a water surface, specifically focusing on patterns created when multiple coherent wave sources are arranged at the vertices of a regular polygon. Understanding these patterns provides insight into fundamental wave behavior and the principle of superposition.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-propagation-from-a-point-source","text":"A circular wave on the water surface emanating from a point source located at \\((x_0, y_0)\\) can be described by the Single Disturbance equation: \\(\\eta(x,y,t) = \\frac{A}{r} \\cdot \\cos(kr - \\omega t + \\phi)\\) Where: - \\(\\eta(x,y,t)\\) is the displacement of the water surface at point \\((x,y)\\) and time \\(t\\) - \\(A\\) is the amplitude of the wave - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) - \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) - \\(r = \\sqrt{(x-x_0)^2 + (y-y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) - \\(\\phi\\) is the initial phase","title":"Wave Propagation from a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#principle-of-superposition","text":"When multiple waves overlap, the resulting displacement at any point is the sum of the individual wave displacements. For \\(N\\) wave sources, the total displacement is: \\(\\eta_{sum}(x,y,t) = \\sum_{i=1}^{N} \\eta_i(x,y,t)\\) The resulting interference pattern can be characterized by regions of: - Constructive interference : Where waves reinforce each other, creating larger amplitudes - Destructive interference : Where waves cancel each other, resulting in reduced or zero amplitude","title":"Principle of Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#numerical-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from matplotlib import cm from mpl_toolkits.mplot3d import Axes3D def create_polygon_vertices(n_sides, radius=1.0, center=(0, 0)): \"\"\" Generate vertices of a regular polygon. Parameters: ----------- n_sides : int Number of sides in the regular polygon radius : float, optional Distance from center to each vertex center : tuple, optional (x, y) coordinates of the polygon center Returns: -------- vertices : numpy.ndarray Array of vertex coordinates with shape (n_sides, 2) \"\"\" angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) vertices = np.zeros((n_sides, 2)) for i, angle in enumerate(angles): vertices[i, 0] = center[0] + radius * np.cos(angle) vertices[i, 1] = center[1] + radius * np.sin(angle) return vertices def wave_displacement(x, y, source_x, source_y, amplitude, k, omega, t, phase=0): \"\"\" Calculate wave displacement at point (x, y) from a source at (source_x, source_y). Parameters: ----------- x, y : float or numpy.ndarray Coordinates where displacement is calculated source_x, source_y : float Coordinates of the wave source amplitude : float Wave amplitude k : float Wave number (2\u03c0/\u03bb) omega : float Angular frequency (2\u03c0f) t : float Time phase : float, optional Initial phase of the wave Returns: -------- displacement : float or numpy.ndarray Wave displacement at point (x, y) \"\"\" r = np.sqrt((x - source_x)**2 + (y - source_y)**2) # Add small constant to avoid division by zero r = np.maximum(r, 1e-10) return amplitude / np.sqrt(r) * np.cos(k * r - omega * t + phase) def calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, t): \"\"\" Calculate interference pattern from multiple sources. Parameters: ----------- x_grid, y_grid : numpy.ndarray Meshgrid of x and y coordinates sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) amplitude : float Wave amplitude k : float Wave number (2\u03c0/\u03bb) omega : float Angular frequency (2\u03c0f) t : float Time Returns: -------- total_displacement : numpy.ndarray Total wave displacement at each point in the grid \"\"\" total_displacement = np.zeros_like(x_grid) for i in range(len(sources)): source_x, source_y = sources[i] # Calculate phase based on source index for variety phase = i * 2 * np.pi / len(sources) displacement = wave_displacement(x_grid, y_grid, source_x, source_y, amplitude, k, omega, t, phase) total_displacement += displacement return total_displacement def plot_interference_pattern(sources, size=10, resolution=500, amplitude=1.0, wavelength=1.0, frequency=1.0, time=0, plot_3d=False): \"\"\" Plot interference pattern from sources at a given time. Parameters: ----------- sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) size : float, optional Size of the plotting domain resolution : int, optional Grid resolution amplitude : float, optional Wave amplitude wavelength : float, optional Wavelength of the waves frequency : float, optional Frequency of the waves time : float, optional Time at which to calculate the interference pattern plot_3d : bool, optional Whether to create a 3D surface plot Returns: -------- fig : matplotlib.figure.Figure The created figure \"\"\" # Calculate wave parameters k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create grid x = np.linspace(-size/2, size/2, resolution) y = np.linspace(-size/2, size/2, resolution) x_grid, y_grid = np.meshgrid(x, y) # Calculate interference pattern z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, time) if plot_3d: # 3D surface plot fig = plt.figure(figsize=(12, 10)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(x_grid, y_grid, z_grid, cmap=cm.coolwarm, linewidth=0, antialiased=True) ax.set_zlim(-amplitude * 3, amplitude * 3) ax.set_xlabel('X position') ax.set_ylabel('Y position') ax.set_zlabel('Wave height') fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5) else: # 2D color map fig, ax = plt.subplots(figsize=(10, 8)) im = ax.imshow(z_grid, extent=[-size/2, size/2, -size/2, size/2], origin='lower', cmap='coolwarm') # Plot source locations for source in sources: ax.plot(source[0], source[1], 'ko', markersize=8) # Customize plot ax.set_xlabel('X position') ax.set_ylabel('Y position') plt.title(f'Wave Interference Pattern at t={time:.2f}s') fig.colorbar(im, ax=ax) return fig def animate_interference(sources, size=10, resolution=200, amplitude=1.0, wavelength=1.0, frequency=1.0, duration=5.0, fps=30): \"\"\" Create animation of evolving interference pattern. Parameters: ----------- sources : numpy.ndarray Array of source coordinates with shape (n_sources, 2) size : float, optional Size of the plotting domain resolution : int, optional Grid resolution amplitude : float, optional Wave amplitude wavelength : float, optional Wavelength of the waves frequency : float, optional Frequency of the waves duration : float, optional Duration of the animation in seconds fps : int, optional Frames per second Returns: -------- anim : matplotlib.animation.FuncAnimation Animation object \"\"\" # Calculate wave parameters k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create grid x = np.linspace(-size/2, size/2, resolution) y = np.linspace(-size/2, size/2, resolution) x_grid, y_grid = np.meshgrid(x, y) # Setup figure for animation fig, ax = plt.subplots(figsize=(10, 8)) # Initial frame z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, 0) im = ax.imshow(z_grid, extent=[-size/2, size/2, -size/2, size/2], origin='lower', cmap='coolwarm', animated=True) # Plot source locations for source in sources: ax.plot(source[0], source[1], 'ko', markersize=8) # Customize plot ax.set_xlabel('X position') ax.set_ylabel('Y position') title = ax.set_title('Wave Interference Pattern at t=0.00s') fig.colorbar(im, ax=ax) def update(frame): \"\"\"Update function for animation.\"\"\" time = frame / fps z_grid = calculate_interference(x_grid, y_grid, sources, amplitude, k, omega, time) im.set_array(z_grid) title.set_text(f'Wave Interference Pattern at t={time:.2f}s') return im, title frames = int(duration * fps) anim = FuncAnimation(fig, update, frames=frames, interval=1000/fps, blit=True) return anim def analyze_regular_polygon(n_sides, radius=5.0, size=20, wavelength=2.0, save_animation=False, save_pattern=False): \"\"\" Analyze interference pattern for a regular polygon arrangement of sources. Parameters: ----------- n_sides : int Number of sides of the regular polygon radius : float, optional Radius of the polygon size : float, optional Size of the plotting domain wavelength : float, optional Wavelength of the waves save_animation : bool, optional Whether to save the animation save_pattern : bool, optional Whether to save the static pattern image Returns: -------- None \"\"\" # Create sources at polygon vertices sources = create_polygon_vertices(n_sides, radius) # Plot initial interference pattern fig_2d = plot_interference_pattern(sources, size=size, wavelength=wavelength, time=0) plt.tight_layout() if save_pattern: plt.savefig(f\"{n_sides}_sided_polygon_interference.png\", dpi=300) plt.figure() # Create 3D visualization fig_3d = plot_interference_pattern(sources, size=size, resolution=200, wavelength=wavelength, time=0, plot_3d=True) plt.tight_layout() if save_pattern: plt.savefig(f\"{n_sides}_sided_polygon_interference_3d.png\", dpi=300) # Create animation anim = animate_interference(sources, size=size, wavelength=wavelength, duration=5.0, fps=15) if save_animation: anim.save(f\"{n_sides}_sided_polygon_interference.mp4\", writer='ffmpeg', fps=15, dpi=200) plt.show() # Print analysis print(f\"Analysis of {n_sides}-sided regular polygon:\") print(f\"- {n_sides} coherent sources placed at vertices of a regular polygon\") print(f\"- Distance between adjacent sources: {2 * radius * np.sin(np.pi/n_sides):.2f} units\") print(f\"- Wavelength: {wavelength} units\") # Calculate central interference center_x, center_y = 0, 0 k = 2 * np.pi / wavelength omega = 2 * np.pi # frequency = 1 by default time = 0 # Check interference at center center_displacement = calculate_interference(center_x, center_y, sources, 1.0, k, omega, time) if abs(center_displacement) > 0.8 * n_sides: print(\"- Center shows strong constructive interference\") elif abs(center_displacement) < 0.2 * n_sides: print(\"- Center shows strong destructive interference\") else: print(\"- Center shows partial interference\") def main(): \"\"\"Run analyses for different regular polygons.\"\"\" # Analyze triangle (3 sides) analyze_regular_polygon(3, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Analyze square (4 sides) analyze_regular_polygon(4, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Analyze pentagon (5 sides) analyze_regular_polygon(5, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) # Optional: Analyze hexagon (6 sides) analyze_regular_polygon(6, radius=5.0, wavelength=2.0, save_animation=True, save_pattern=True) if __name__ == \"__main__\": main()","title":"Numerical Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-interference-patterns","text":"","title":"Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#triangle-3-source-interference","text":"When three coherent wave sources are placed at the vertices of an equilateral triangle, several distinctive interference patterns emerge: Radial Symmetry : The overall pattern displays three-fold radial symmetry, reflecting the geometric arrangement of the sources. Nodal Lines : Clear nodal lines (regions of destructive interference) form between the sources, creating a pattern resembling a distorted star. Central Interference : The interference at the center of the triangle depends on the relationship between the wavelength and the side length of the triangle: When the distance between sources is an integer multiple of wavelength: Constructive interference When the distance is an odd multiple of half-wavelengths: Destructive interference Time Evolution : As time progresses, the pattern appears to rotate while maintaining its overall structure, creating a dynamic visual display of wave interaction.","title":"Triangle (3-Source) Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-analysis-of-interference-conditions","text":"For sources arranged in a regular polygon with \\(N\\) sides and radius \\(R\\) , we can derive the conditions for constructive and destructive interference at various points. For a point at position \\((x, y)\\) , the path difference \\(\\Delta r_i\\) between waves from adjacent sources is: \\(\\Delta r_i = |\\vec{r}_i - \\vec{r}_{i+1}|\\) where \\(\\vec{r}_i\\) is the distance from source \\(i\\) to point \\((x, y)\\) . Constructive Interference Condition : \\(\\Delta r_i = m\\lambda\\) , where \\(m\\) is an integer Destructive Interference Condition : \\(\\Delta r_i = (m+\\frac{1}{2})\\lambda\\) , where \\(m\\) is an integer At the center of the polygon (origin), all sources are equidistant, so: - For even values of \\(N\\) : Adjacent sources are in phase opposition when the polygon radius is an odd multiple of quarter-wavelengths, leading to destructive interference - For odd values of \\(N\\) : Complete destructive interference cannot occur at the center","title":"Mathematical Analysis of Interference Conditions"},{"location":"1%20Physics/3%20Waves/Problem_1/#square-4-source-interference","text":"The square arrangement of sources produces: Four-fold Symmetry : The interference pattern shows clear four-fold symmetry. Checkerboard Pattern : In the central region, alternating regions of constructive and destructive interference create a checkerboard-like pattern. Diagonal Enhancement : Strong constructive interference appears along the diagonals of the square when the diagonal length is appropriately related to the wavelength. Strong Central Interference : The center typically exhibits pronounced interference effects, with the nature (constructive or destructive) depending on the relationship between the square side length and the wavelength.","title":"Square (4-Source) Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#pentagon-and-higher-order-polygons","text":"As the number of sides increases: Increasing Circular Symmetry : The interference pattern begins to approximate circular symmetry, especially at distances far from the sources. Complex Near-field Patterns : Close to the sources, intricate interference patterns form with the same symmetry as the polygon. Central Enhancement : With odd numbers of sides, the center tends to show constructive interference under a wider range of conditions than with even-sided polygons.","title":"Pentagon and Higher-Order Polygons"},{"location":"1%20Physics/3%20Waves/Problem_1/#applications-and-extensions","text":"The study of interference patterns from regularly spaced sources has numerous applications: Phased Array Systems : Used in radar, sonar, and communications to direct signals through constructive interference. Antenna Design : Multiple antennas arranged in specific geometric patterns can enhance signal strength in desired directions. Acoustic Engineering : Understanding multi-source interference helps in designing concert halls and speaker systems. Optical Phenomena : Similar principles govern multiple-slit diffraction and interference in optics. Extensions to this study could include: - Varying the amplitude or phase of individual sources - Introducing time delays between sources - Considering non-uniform mediums where wave speed varies with position","title":"Applications and Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"The interference patterns created by waves from sources arranged in regular polygons demonstrate the rich behavior emerging from the superposition principle. These patterns exhibit symmetry reflecting the source arrangement and create regions of enhanced and diminished wave amplitude based on the phase relationships between overlapping waves. Through numerical simulation, we can visualize these complex patterns and understand the conditions that lead to constructive and destructive interference. This analysis provides insight into fundamental wave behavior with applications across multiple fields of physics and engineering.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force Introduction The Lorentz force governs the interaction of charged particles with electric and magnetic fields, described mathematically as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Understanding this force is essential in various fields such as particle physics, astrophysics, and engineering technologies like particle accelerators and plasma confinement systems. This simulation project extensively explores the behavior of charged particles under different electromagnetic field conditions. Theory and Background Lorentz Force The Lorentz force consists of: Electric force ( \\(q\\mathbf{E}\\) ) : Acts in the direction of the electric field, changing particle velocity magnitude. Magnetic force ( \\(q\\mathbf{v}\\times \\mathbf{B}\\) ) : Perpendicular to both particle velocity and magnetic field, modifying trajectory direction without changing speed. The dynamics of a particle under this force follow Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}\\times \\mathbf{B}) \\] Numerical methods such as the Runge-Kutta method are employed to solve these equations. Exploration of Applications Particle Accelerators Charged particles are guided by magnetic fields, achieving high speeds through periodic electric field acceleration, essential for experiments in particle physics. Mass Spectrometry Magnetic fields differentiate particles based on their mass-to-charge ratios, enabling accurate chemical analyses and isotopic identification. Plasma Confinement Magnetic confinement in fusion reactors relies heavily on controlling particle trajectories, maintaining stable plasma conditions necessary for fusion. Simulations Comprehensive Python Implementation Here is a robust and clear Python implementation illustrating particle trajectories under varied electromagnetic conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz force equations def lorentz_force(t, state, q, m, E_func, B_func): pos, vel = state[:3], state[3:] dposdt = vel dveldt = (q/m) * (E_func(pos, t) + np.cross(vel, B_func(pos, t))) return np.concatenate([dposdt, dveldt]) # Field scenarios field_scenarios = { 'Uniform Magnetic Field': (lambda r, t: np.zeros(3), lambda r, t: np.array([0, 0, 1])), 'Combined Fields': (lambda r, t: np.array([0, 1e4, 0]), lambda r, t: np.array([0, 0, 1])), 'Crossed Fields': (lambda r, t: np.array([1e4, 0, 0]), lambda r, t: np.array([0, 0, 1])) } # Simulation parameters q, m = 1.6e-19, 9.11e-31 initial_state = np.array([0, 0, 0, 1e6, 1e6, 0]) t_span, t_eval = (0, 5e-8), np.linspace(0, 5e-8, 5000) for scenario, (E_func, B_func) in field_scenarios.items(): solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E_func, B_func), t_eval=t_eval) fig = plt.figure(figsize=(12, 6)) # 3D Trajectory ax = fig.add_subplot(121, projection='3d') ax.plot(solution.y[0], solution.y[1], solution.y[2], label=scenario) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f'3D Trajectory - {scenario}') ax.legend() # 2D Projection ax2 = fig.add_subplot(122) ax2.plot(solution.y[0], solution.y[1]) ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_title(f'2D Projection - {scenario}') ax2.grid(True) plt.tight_layout() plt.show() Parameter Exploration Examining how trajectory changes with: Electric field magnitude ( \\(\\mathbf{E}\\) ) Magnetic field strength ( \\(\\mathbf{B}\\) ) Initial velocity ( \\(\\mathbf{v}\\) ) Particle charge and mass ( \\(q,m\\) ) helps in understanding particle behavior under various real-world conditions. Visualization Circular trajectory : Observed clearly in uniform magnetic fields. Helical trajectory : Occurs with combined fields. Drift trajectory : Highlighted clearly under crossed fields, showcasing constant drift perpendicular to both fields. Visualization clearly demonstrates important physical parameters: Larmor Radius : \\(r_L = \\frac{mv}{qB}\\) Drift Velocity : \\(v_d = \\frac{E \\times B}{B^2}\\) Extensions Future simulations may incorporate: Non-uniform fields for realistic plasma containment scenarios. Time-varying fields to simulate dynamic environmental interactions. Relativistic dynamics for high-speed particle simulations. Conclusion This detailed simulation effectively illustrates the fundamental and applied aspects of the Lorentz force, providing significant insights into electromagnetic particle dynamics, supporting theoretical understanding and practical applications.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force governs the interaction of charged particles with electric and magnetic fields, described mathematically as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Understanding this force is essential in various fields such as particle physics, astrophysics, and engineering technologies like particle accelerators and plasma confinement systems. This simulation project extensively explores the behavior of charged particles under different electromagnetic field conditions.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theory-and-background","text":"","title":"Theory and Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force","text":"The Lorentz force consists of: Electric force ( \\(q\\mathbf{E}\\) ) : Acts in the direction of the electric field, changing particle velocity magnitude. Magnetic force ( \\(q\\mathbf{v}\\times \\mathbf{B}\\) ) : Perpendicular to both particle velocity and magnetic field, modifying trajectory direction without changing speed. The dynamics of a particle under this force follow Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}\\times \\mathbf{B}) \\] Numerical methods such as the Runge-Kutta method are employed to solve these equations.","title":"Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#exploration-of-applications","text":"","title":"Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"Charged particles are guided by magnetic fields, achieving high speeds through periodic electric field acceleration, essential for experiments in particle physics.","title":"Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometry","text":"Magnetic fields differentiate particles based on their mass-to-charge ratios, enabling accurate chemical analyses and isotopic identification.","title":"Mass Spectrometry"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","text":"Magnetic confinement in fusion reactors relies heavily on controlling particle trajectories, maintaining stable plasma conditions necessary for fusion.","title":"Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulations","text":"","title":"Simulations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#comprehensive-python-implementation","text":"Here is a robust and clear Python implementation illustrating particle trajectories under varied electromagnetic conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz force equations def lorentz_force(t, state, q, m, E_func, B_func): pos, vel = state[:3], state[3:] dposdt = vel dveldt = (q/m) * (E_func(pos, t) + np.cross(vel, B_func(pos, t))) return np.concatenate([dposdt, dveldt]) # Field scenarios field_scenarios = { 'Uniform Magnetic Field': (lambda r, t: np.zeros(3), lambda r, t: np.array([0, 0, 1])), 'Combined Fields': (lambda r, t: np.array([0, 1e4, 0]), lambda r, t: np.array([0, 0, 1])), 'Crossed Fields': (lambda r, t: np.array([1e4, 0, 0]), lambda r, t: np.array([0, 0, 1])) } # Simulation parameters q, m = 1.6e-19, 9.11e-31 initial_state = np.array([0, 0, 0, 1e6, 1e6, 0]) t_span, t_eval = (0, 5e-8), np.linspace(0, 5e-8, 5000) for scenario, (E_func, B_func) in field_scenarios.items(): solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E_func, B_func), t_eval=t_eval) fig = plt.figure(figsize=(12, 6)) # 3D Trajectory ax = fig.add_subplot(121, projection='3d') ax.plot(solution.y[0], solution.y[1], solution.y[2], label=scenario) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f'3D Trajectory - {scenario}') ax.legend() # 2D Projection ax2 = fig.add_subplot(122) ax2.plot(solution.y[0], solution.y[1]) ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_title(f'2D Projection - {scenario}') ax2.grid(True) plt.tight_layout() plt.show()","title":"Comprehensive Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration","text":"Examining how trajectory changes with: Electric field magnitude ( \\(\\mathbf{E}\\) ) Magnetic field strength ( \\(\\mathbf{B}\\) ) Initial velocity ( \\(\\mathbf{v}\\) ) Particle charge and mass ( \\(q,m\\) ) helps in understanding particle behavior under various real-world conditions.","title":"Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization","text":"Circular trajectory : Observed clearly in uniform magnetic fields. Helical trajectory : Occurs with combined fields. Drift trajectory : Highlighted clearly under crossed fields, showcasing constant drift perpendicular to both fields. Visualization clearly demonstrates important physical parameters: Larmor Radius : \\(r_L = \\frac{mv}{qB}\\) Drift Velocity : \\(v_d = \\frac{E \\times B}{B^2}\\)","title":"Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Future simulations may incorporate: Non-uniform fields for realistic plasma containment scenarios. Time-varying fields to simulate dynamic environmental interactions. Relativistic dynamics for high-speed particle simulations.","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This detailed simulation effectively illustrates the fundamental and applied aspects of the Lorentz force, providing significant insights into electromagnetic particle dynamics, supporting theoretical understanding and practical applications.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 1. Simulating Sampling Distributions Selected Population Distributions We'll use the following types: Uniform Distribution (e.g., between 0 and 1) Exponential Distribution (e.g., scale = 1.0) Binomial Distribution (e.g., \\(n = 10\\) , \\(p = 0.5\\) ) Python Code to Generate Populations import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Population sizes pop_size = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(scale=1.0, size=pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size) # Plot each distribution plt.figure(figsize=(15, 4)) # Uniform plt.subplot(1, 3, 1) sns.histplot(uniform_pop, kde=True, bins=50, color='skyblue') plt.title(\"Uniform Distribution\") # Exponential plt.subplot(1, 3, 2) sns.histplot(exponential_pop, kde=True, bins=50, color='orange') plt.title(\"Exponential Distribution\") # Binomial plt.subplot(1, 3, 3) sns.histplot(binomial_pop, kde=True, bins=50, color='green') plt.title(\"Binomial Distribution\") plt.tight_layout() plt.show() 2. Sampling and Visualization Sampling Strategy Choose different sample sizes: 5, 10, 30, 50 Draw many random samples (e.g., 1000 samples per size) Calculate the sample mean for each sample Plot the distribution of sample means Python Code for Sampling and Plotting import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Define population (you can change this to uniform_pop, exponential_pop, etc.) population = np.random.exponential(scale=1.0, size=100000) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Repetitions per sample size # Set up plot plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n) sample_means.append(np.mean(sample)) # Plot histogram of sample means plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color='purple') plt.title(f'Sample Size = {n}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle(\"Sampling Distributions of the Mean\", y=1.02, fontsize=16) plt.show() 3. Parameter Exploration Key Factors to Investigate Original distribution shape: Symmetric (Uniform) Skewed (Exponential) Discrete (Binomial) Sample size: Small (e.g., 5\u201310) \u2192 slow convergence Larger (e.g., 30\u201350) \u2192 faster convergence Population variance: Affects spread of the sampling distribution High variance \u2192 wider sampling distribution Observations to Highlight Exponential Distribution: Strongly skewed, but sample means become symmetric with larger \\(n\\) . Uniform Distribution: Converges quickly since it\u2019s already bounded and symmetric. Binomial Distribution (with low \\(n\\) ): Discrete jumps are visible, but smooth out with sampling. Higher Variance = Slower Convergence: Sample means spread out more, requiring larger \\(n\\) to approach normality. 4. Practical Applications of the Central Limit Theorem Why CLT Matters The Central Limit Theorem (CLT) is critical in statistics because it allows us to make predictions and decisions based on sample data , even if the population distribution is unknown. Estimating Population Parameters Sample means follow a normal distribution for large enough samples. Enables construction of confidence intervals and hypothesis testing . Used in surveys, experiments, and polling (e.g., predicting election outcomes). Quality Control in Manufacturing CLT helps track mean product quality over time. Sample-based control charts rely on the assumption that the mean of measurements is normally distributed . Essential for detecting shifts or defects in production. Financial Modeling Returns and risks are modeled assuming normally distributed averages . CLT justifies using sample averages to estimate expected returns or volatility. Supports risk analysis and portfolio optimization .","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#selected-population-distributions","text":"We'll use the following types: Uniform Distribution (e.g., between 0 and 1) Exponential Distribution (e.g., scale = 1.0) Binomial Distribution (e.g., \\(n = 10\\) , \\(p = 0.5\\) )","title":"Selected Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-to-generate-populations","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Population sizes pop_size = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(scale=1.0, size=pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size) # Plot each distribution plt.figure(figsize=(15, 4)) # Uniform plt.subplot(1, 3, 1) sns.histplot(uniform_pop, kde=True, bins=50, color='skyblue') plt.title(\"Uniform Distribution\") # Exponential plt.subplot(1, 3, 2) sns.histplot(exponential_pop, kde=True, bins=50, color='orange') plt.title(\"Exponential Distribution\") # Binomial plt.subplot(1, 3, 3) sns.histplot(binomial_pop, kde=True, bins=50, color='green') plt.title(\"Binomial Distribution\") plt.tight_layout() plt.show()","title":"Python Code to Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-strategy","text":"Choose different sample sizes: 5, 10, 30, 50 Draw many random samples (e.g., 1000 samples per size) Calculate the sample mean for each sample Plot the distribution of sample means","title":"Sampling Strategy"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-for-sampling-and-plotting","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Define population (you can change this to uniform_pop, exponential_pop, etc.) population = np.random.exponential(scale=1.0, size=100000) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Repetitions per sample size # Set up plot plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n) sample_means.append(np.mean(sample)) # Plot histogram of sample means plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color='purple') plt.title(f'Sample Size = {n}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle(\"Sampling Distributions of the Mean\", y=1.02, fontsize=16) plt.show()","title":"Python Code for Sampling and Plotting"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-factors-to-investigate","text":"Original distribution shape: Symmetric (Uniform) Skewed (Exponential) Discrete (Binomial) Sample size: Small (e.g., 5\u201310) \u2192 slow convergence Larger (e.g., 30\u201350) \u2192 faster convergence Population variance: Affects spread of the sampling distribution High variance \u2192 wider sampling distribution","title":"Key Factors to Investigate"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-to-highlight","text":"Exponential Distribution: Strongly skewed, but sample means become symmetric with larger \\(n\\) . Uniform Distribution: Converges quickly since it\u2019s already bounded and symmetric. Binomial Distribution (with low \\(n\\) ): Discrete jumps are visible, but smooth out with sampling. Higher Variance = Slower Convergence: Sample means spread out more, requiring larger \\(n\\) to approach normality.","title":"Observations to Highlight"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-the-central-limit-theorem","text":"","title":"4. Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#why-clt-matters","text":"The Central Limit Theorem (CLT) is critical in statistics because it allows us to make predictions and decisions based on sample data , even if the population distribution is unknown.","title":"Why CLT Matters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#estimating-population-parameters","text":"Sample means follow a normal distribution for large enough samples. Enables construction of confidence intervals and hypothesis testing . Used in surveys, experiments, and polling (e.g., predicting election outcomes).","title":"Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quality-control-in-manufacturing","text":"CLT helps track mean product quality over time. Sample-based control charts rely on the assumption that the mean of measurements is normally distributed . Essential for detecting shifts or defects in production.","title":"Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#financial-modeling","text":"Returns and risks are modeled assuming normally distributed averages . CLT justifies using sample averages to estimate expected returns or volatility. Supports risk analysis and portfolio optimization .","title":"Financial Modeling"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo \u2013 Circle Method 1. Theoretical Foundation We estimate \u03c0 by simulating points in a square and checking how many fall inside an inscribed circle. For a unit circle centered at the origin, any point \\((x, y)\\) lies inside the circle if: \\[ x^2 + y^2 \\leq 1 \\] The area of the full square is \\(4\\) (from \\([-1, 1] \\times [-1, 1]\\) ). The area of the unit circle is \\(\u03c0\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\u03c0}{4} \\] Rearranging: \\[ \u03c0 \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\] 2. Simulation \u2013 Estimating \u03c0 import numpy as np def estimate_pi(num_points=10000): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example usage pi, x_vals, y_vals, mask = estimate_pi(10000) print(f\"Estimated \u03c0 \u2248 {pi}\") Estimated \u03c0 \u2248 3.1548 3. Visualization of Points import matplotlib.pyplot as plt def plot_points(x, y, inside_circle): plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo \u03c0 Estimation\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.grid(True) plt.show() plot_points(x_vals, y_vals, mask) 4. Accuracy and Convergence Observing Convergencee import matplotlib.pyplot as plt sample_sizes = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates = [] for n in sample_sizes: pi_est, *_ = estimate_pi(n) estimates.append(pi_est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale('log') plt.show() Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Problem Description Buffon\u2019s Needle is a classic probability problem: Drop a needle of length \\(L\\) onto a plane with equally spaced parallel lines a distance \\(d\\) apart. The probability \\(P\\) of the needle crossing a line is related to \\(\u03c0\\) : \\[ P = \\frac{2L}{d\u03c0} \\] Deriving \u03c0 Rearranged to estimate \u03c0: \\[ \u03c0 \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) = needle length - \\(d\\) = distance between lines - \\(N\\) = total number of throws - \\(C\\) = number of times the needle crosses a line Note: Valid only when \\(L \\leq d\\) 2. Simulation import numpy as np def buffon_needle(num_throws=10000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Random needle midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) # Estimate \u03c0 if num_crosses == 0: return None # Avoid division by zero pi_est = (2 * L * num_throws) / (d * num_crosses) return pi_est, y_center, theta, crosses only runs the calculation \u2014 it doesn't produce a plot by itself. 3. Visualization import matplotlib.pyplot as plt def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=200): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color) # Draw parallel lines for y in np.arange(0, 10*d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossing)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis('equal') plt.grid(True) plt.show() It doesnt produce a plot because it needs input from the simulation first. The following code below builds on the Buffon\u2019s Needle simulation and includes a visual representation of the needle drops: Red needles indicate those that crossed a line. Blue needles indicate those that did not cross . Dashed black lines represent the parallel floor lines . This visualization helps us understand how the estimate of \u03c0 is formed geometrically. It uses the output from the simulation to produce an intuitive and engaging plot of the experiment. import numpy as np import matplotlib.pyplot as plt # --- Buffon\u2019s Needle Simulation --- def buffon_needle(num_throws=1000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Generate random midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None, y_center, theta, crosses # Avoid division by zero # Estimate \u03c0 pi_estimate = (2 * L * num_throws) / (d * num_crosses) return pi_estimate, y_center, theta, crosses # --- Needle Plotting Function --- def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=300): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) # Draw parallel lines for y in np.arange(0, 10 * d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossed Line)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis(\"equal\") plt.grid(True) plt.show() # --- Run Simulation and Plot --- pi_val, y_vals, theta_vals, cross_mask = buffon_needle(num_throws=1000) print(f\"Estimated \u03c0 \u2248 {pi_val:.6f}\") plot_needles(y_vals, theta_vals, cross_mask) 4. Analysis of Accuracy and Convergence sample_sizes = [100, 500, 1000, 5000, 10000, 50000] pi_estimates = [] for n in sample_sizes: pi_val, *_ = buffon_needle(num_throws=n) pi_estimates.append(pi_val) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.title(\"Buffon\u2019s Needle: Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale(\"log\") plt.show()","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-circle-method","text":"","title":"Estimating \u03c0 Using Monte Carlo \u2013 Circle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We estimate \u03c0 by simulating points in a square and checking how many fall inside an inscribed circle. For a unit circle centered at the origin, any point \\((x, y)\\) lies inside the circle if: \\[ x^2 + y^2 \\leq 1 \\] The area of the full square is \\(4\\) (from \\([-1, 1] \\times [-1, 1]\\) ). The area of the unit circle is \\(\u03c0\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\u03c0}{4} \\] Rearranging: \\[ \u03c0 \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-estimating","text":"import numpy as np def estimate_pi(num_points=10000): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example usage pi, x_vals, y_vals, mask = estimate_pi(10000) print(f\"Estimated \u03c0 \u2248 {pi}\") Estimated \u03c0 \u2248 3.1548","title":"2. Simulation \u2013 Estimating \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization-of-points","text":"import matplotlib.pyplot as plt def plot_points(x, y, inside_circle): plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo \u03c0 Estimation\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.grid(True) plt.show() plot_points(x_vals, y_vals, mask)","title":"3. Visualization of Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-accuracy-and-convergence","text":"","title":"4. Accuracy and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observing-convergencee","text":"import matplotlib.pyplot as plt sample_sizes = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates = [] for n in sample_sizes: pi_est, *_ = estimate_pi(n) estimates.append(pi_est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale('log') plt.show()","title":"Observing Convergencee"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-buffons-needle","text":"","title":"Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-description","text":"Buffon\u2019s Needle is a classic probability problem: Drop a needle of length \\(L\\) onto a plane with equally spaced parallel lines a distance \\(d\\) apart. The probability \\(P\\) of the needle crossing a line is related to \\(\u03c0\\) : \\[ P = \\frac{2L}{d\u03c0} \\]","title":"Problem Description"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deriving","text":"Rearranged to estimate \u03c0: \\[ \u03c0 \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) = needle length - \\(d\\) = distance between lines - \\(N\\) = total number of throws - \\(C\\) = number of times the needle crosses a line Note: Valid only when \\(L \\leq d\\)","title":"Deriving \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"import numpy as np def buffon_needle(num_throws=10000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Random needle midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) # Estimate \u03c0 if num_crosses == 0: return None # Avoid division by zero pi_est = (2 * L * num_throws) / (d * num_crosses) return pi_est, y_center, theta, crosses only runs the calculation \u2014 it doesn't produce a plot by itself.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"import matplotlib.pyplot as plt def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=200): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color) # Draw parallel lines for y in np.arange(0, 10*d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossing)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis('equal') plt.grid(True) plt.show() It doesnt produce a plot because it needs input from the simulation first. The following code below builds on the Buffon\u2019s Needle simulation and includes a visual representation of the needle drops: Red needles indicate those that crossed a line. Blue needles indicate those that did not cross . Dashed black lines represent the parallel floor lines . This visualization helps us understand how the estimate of \u03c0 is formed geometrically. It uses the output from the simulation to produce an intuitive and engaging plot of the experiment. import numpy as np import matplotlib.pyplot as plt # --- Buffon\u2019s Needle Simulation --- def buffon_needle(num_throws=1000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Generate random midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None, y_center, theta, crosses # Avoid division by zero # Estimate \u03c0 pi_estimate = (2 * L * num_throws) / (d * num_crosses) return pi_estimate, y_center, theta, crosses # --- Needle Plotting Function --- def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=300): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) # Draw parallel lines for y in np.arange(0, 10 * d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossed Line)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis(\"equal\") plt.grid(True) plt.show() # --- Run Simulation and Plot --- pi_val, y_vals, theta_vals, cross_mask = buffon_needle(num_throws=1000) print(f\"Estimated \u03c0 \u2248 {pi_val:.6f}\") plot_needles(y_vals, theta_vals, cross_mask)","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis-of-accuracy-and-convergence","text":"sample_sizes = [100, 500, 1000, 5000, 10000, 50000] pi_estimates = [] for n in sample_sizes: pi_val, *_ = buffon_needle(num_throws=n) pi_estimates.append(pi_val) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.title(\"Buffon\u2019s Needle: Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale(\"log\") plt.show()","title":"4. Analysis of Accuracy and Convergence"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity ( \\(g\\) ) is a fundamental physical constant that affects a wide variety of phenomena. Accurate measurement of \\(g\\) is essential in understanding gravitational interactions, engineering applications, and experimental physics. One reliable method to determine \\(g\\) is through the oscillation period of a simple pendulum. The relationship between the pendulum's period and its length allows us to estimate \\(g\\) while also analyzing the impact of measurement uncertainties. Task Measure the local gravitational acceleration \\(g\\) using a pendulum setup. Carefully analyze uncertainties to understand the precision of your measurements and how experimental limitations influence the final result. Procedure 1. Materials A string (1 or 1.5 meters long). A small mass (e.g., a metal washer, keychain, or small bag). Stopwatch (or smartphone timer). Ruler or measuring tape. 2. Setup Securely attach the weight to the end of the string and fix the other end to a stable point. Measure the length \\(L\\) of the pendulum from the suspension point to the center of the mass. Record the ruler resolution \\(\\Delta L\\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 3. Data Collection Displace the pendulum by a small angle (<15\u00b0) and release. Measure the time for 10 oscillations ( \\(T_{10}\\) ). Repeat this 10 times. Compute the average \\(\\overline{T_{10}}\\) and standard deviation \\(\\sigma_{T}\\) . Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 \\] Calculations 1. Calculate the Period \\[ T = \\frac{\\overline{T_{10}}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 2. Determine g \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate Uncertainties \\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(\\frac{2 \\Delta T}{T}\\right)^2 } \\] Python Code for Analysis import numpy as np # Sample data (user should replace with actual values) L = 1.00 # length of pendulum in meters ruler_resolution = 0.01 # in meters T10_measurements = [20.1, 20.3, 20.2, 20.0, 20.4, 20.2, 20.3, 20.1, 20.2, 20.3] # in seconds # Calculations n = len(T10_measurements) T10_array = np.array(T10_measurements) T10_mean = np.mean(T10_array) sigma_T10 = np.std(T10_array, ddof=1) Delta_T10 = sigma_T10 / np.sqrt(n) T = T10_mean / 10 Delta_T = Delta_T10 / 10 Delta_L = ruler_resolution / 2 g = (4 * np.pi**2 * L) / (T**2) Delta_g = g * np.sqrt((Delta_L / L)**2 + ((2 * Delta_T) / T)**2) # Output print(f\"Mean T10: {T10_mean:.4f} s\") print(f\"Standard deviation (\u03c3_T10): {sigma_T10:.4f} s\") print(f\"Period T: {T:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2\") print(f\"Uncertainty in g (\u0394g): {Delta_g:.4f} m/s\u00b2\") import matplotlib.pyplot as plt # Plot individual T10 measurements plt.figure(figsize=(8, 5)) plt.plot(T10_measurements, marker='o', linestyle='-', color='blue', label='T\u2081\u2080 Measurements') plt.axhline(T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Measured Times for 10 Oscillations (T\u2081\u2080)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (seconds)\") plt.grid(True) plt.legend() plt.tight_layout() # Show plot plt.show() # Optionally save plot plt.savefig(\"pendulum_T10_measurements.png\", dpi=300) Analysis Compare your measured \\(g\\) with the accepted standard value ( \\(9.81\\, m/s^2\\) ). Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Timing variability and its impact on \\(\\Delta T\\) . Experimental assumptions and sources of error (e.g., air resistance, angle, stopwatch lag). Deliverables A Markdown table including: Measured \\(L\\) , \\(\\Delta L\\) , 10 values of \\(T_{10}\\) , \\(\\overline{T_{10}}\\) , \\(\\sigma_T\\) , and \\(\\Delta T\\) . Calculated values of \\(g\\) and \\(\\Delta g\\) . A discussion on: Sources of uncertainty. Comparison to standard gravity. How measurement practices affect result reliability.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity ( \\(g\\) ) is a fundamental physical constant that affects a wide variety of phenomena. Accurate measurement of \\(g\\) is essential in understanding gravitational interactions, engineering applications, and experimental physics. One reliable method to determine \\(g\\) is through the oscillation period of a simple pendulum. The relationship between the pendulum's period and its length allows us to estimate \\(g\\) while also analyzing the impact of measurement uncertainties.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the local gravitational acceleration \\(g\\) using a pendulum setup. Carefully analyze uncertainties to understand the precision of your measurements and how experimental limitations influence the final result.","title":"Task"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long). A small mass (e.g., a metal washer, keychain, or small bag). Stopwatch (or smartphone timer). Ruler or measuring tape.","title":"1. Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Securely attach the weight to the end of the string and fix the other end to a stable point. Measure the length \\(L\\) of the pendulum from the suspension point to the center of the mass. Record the ruler resolution \\(\\Delta L\\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"2. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Displace the pendulum by a small angle (<15\u00b0) and release. Measure the time for 10 oscillations ( \\(T_{10}\\) ). Repeat this 10 times. Compute the average \\(\\overline{T_{10}}\\) and standard deviation \\(\\sigma_{T}\\) . Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 \\]","title":"3. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\[ T = \\frac{\\overline{T_{10}}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"1. Calculate the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Determine g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(\\frac{2 \\Delta T}{T}\\right)^2 } \\]","title":"3. Propagate Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code-for-analysis","text":"import numpy as np # Sample data (user should replace with actual values) L = 1.00 # length of pendulum in meters ruler_resolution = 0.01 # in meters T10_measurements = [20.1, 20.3, 20.2, 20.0, 20.4, 20.2, 20.3, 20.1, 20.2, 20.3] # in seconds # Calculations n = len(T10_measurements) T10_array = np.array(T10_measurements) T10_mean = np.mean(T10_array) sigma_T10 = np.std(T10_array, ddof=1) Delta_T10 = sigma_T10 / np.sqrt(n) T = T10_mean / 10 Delta_T = Delta_T10 / 10 Delta_L = ruler_resolution / 2 g = (4 * np.pi**2 * L) / (T**2) Delta_g = g * np.sqrt((Delta_L / L)**2 + ((2 * Delta_T) / T)**2) # Output print(f\"Mean T10: {T10_mean:.4f} s\") print(f\"Standard deviation (\u03c3_T10): {sigma_T10:.4f} s\") print(f\"Period T: {T:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2\") print(f\"Uncertainty in g (\u0394g): {Delta_g:.4f} m/s\u00b2\") import matplotlib.pyplot as plt # Plot individual T10 measurements plt.figure(figsize=(8, 5)) plt.plot(T10_measurements, marker='o', linestyle='-', color='blue', label='T\u2081\u2080 Measurements') plt.axhline(T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Measured Times for 10 Oscillations (T\u2081\u2080)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (seconds)\") plt.grid(True) plt.legend() plt.tight_layout() # Show plot plt.show() # Optionally save plot plt.savefig(\"pendulum_T10_measurements.png\", dpi=300)","title":"Python Code for Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Compare your measured \\(g\\) with the accepted standard value ( \\(9.81\\, m/s^2\\) ). Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Timing variability and its impact on \\(\\Delta T\\) . Experimental assumptions and sources of error (e.g., air resistance, angle, stopwatch lag).","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"A Markdown table including: Measured \\(L\\) , \\(\\Delta L\\) , 10 values of \\(T_{10}\\) , \\(\\overline{T_{10}}\\) , \\(\\sigma_T\\) , and \\(\\Delta T\\) . Calculated values of \\(g\\) and \\(\\Delta g\\) . A discussion on: Sources of uncertainty. Comparison to standard gravity. How measurement practices affect result reliability.","title":"Deliverables"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}