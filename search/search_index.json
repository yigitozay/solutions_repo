{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion Analysis: Range vs. Angle of Projection 1. Theoretical Foundation Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity Horizontal motion: No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\) Vertical motion: Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\) Trajectory equation: Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas 2. Range Analysis Range formula (for ground-level launch): \\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance Angle dependence: Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch) Parameter effects: Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\) 3. Practical Applications Sports applications: Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots Engineering applications: Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles Space exploration: Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth 4. Implementation Computational approach: Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization Key visualizations: Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity Simulation capabilities: Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments 5. Limitations and Extensions Current limitations: No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces Possible improvements: Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions Python Implementation # Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-range-vs-angle-of-projection","text":"","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\)","title":"Horizontal motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\)","title":"Vertical motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas","title":"Trajectory equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis","text":"","title":"2. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula-for-ground-level-launch","text":"\\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance","title":"Range formula (for ground-level launch):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#angle-dependence","text":"Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch)","title":"Angle dependence:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\)","title":"Parameter effects:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports-applications","text":"Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots","title":"Sports applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering-applications","text":"Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles","title":"Engineering applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-exploration","text":"Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth","title":"Space exploration:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-approach","text":"Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization","title":"Computational approach:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-visualizations","text":"Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity","title":"Key visualizations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-capabilities","text":"Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments","title":"Simulation capabilities:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#current-limitations","text":"No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces","title":"Current limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-improvements","text":"Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions","title":"Possible improvements:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-implementation","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum 1. Theoretical Foundation Basic Pendulum Model A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve. Resonance Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing 2. Different Behaviors Effect of Damping Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates Effect of Force Strength Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable Effect of Force Frequency Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements Chaos When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random) 3. Real-World Applications Engineering Examples Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy Similar Systems Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings 4. Computer Simulation Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior Key Visualizations Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum() 5. Limitations and Extensions Current Limitations Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force Possible Improvements Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other Summary The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#basic-pendulum-model","text":"A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve.","title":"Basic Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-different-behaviors","text":"","title":"2. Different Behaviors"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping","text":"Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates","title":"Effect of Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-strength","text":"Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable","title":"Effect of Force Strength"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-frequency","text":"Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements","title":"Effect of Force Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos","text":"When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random)","title":"Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#engineering-examples","text":"Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy","title":"Engineering Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#similar-systems","text":"Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings","title":"Similar Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computer-simulation","text":"Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior","title":"4. Computer Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-visualizations","text":"Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos","title":"Key Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum()","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#current-limitations","text":"Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force","title":"Current Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-improvements","text":"Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other","title":"Possible Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}