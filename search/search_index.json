{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Projectile Motion Analysis: Range vs. Angle of Projection 1. Theoretical Foundation Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity Horizontal motion: No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\) Vertical motion: Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\) Trajectory equation: Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas 2. Range Analysis Range formula (for ground-level launch): \\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance Angle dependence: Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch) Parameter effects: Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\) 3. Practical Applications Sports applications: Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots Engineering applications: Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles Space exploration: Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth 4. Implementation Computational approach: Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization Key visualizations: Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity Simulation capabilities: Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments 5. Limitations and Extensions Current limitations: No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces Possible improvements: Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions Python Implementation # Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-range-vs-angle-of-projection","text":"","title":"Projectile Motion Analysis: Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Basic principles : Projectile motion combines constant horizontal velocity with accelerated vertical motion due to gravity","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"No forces act horizontally (ignoring air resistance) Acceleration \\(a_x = 0\\) Velocity remains constant: \\(v_x = v_0\\cos\\theta\\) Position: \\(x(t) = v_0\\cos\\theta \\times t\\)","title":"Horizontal motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Gravity pulls downward: \\(a_y = -g\\) Velocity decreases linearly: \\(v_y = v_0\\sin\\theta - gt\\) Position: \\(y(t) = h_0 + v_0\\sin\\theta \\times t - \\frac{1}{2}gt^2\\)","title":"Vertical motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation","text":"Parabolic path: \\(y = h_0 + x\\tan\\theta - \\frac{g\\times x^2}{2v_0^2\\cos^2\\theta}\\) Different initial conditions create a family of parabolas","title":"Trajectory equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis","text":"","title":"2. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula-for-ground-level-launch","text":"\\(R = \\frac{v_0^2\\sin(2\\theta)}{g}\\) Derived by finding when \\(y(t) = 0\\) and calculating horizontal distance","title":"Range formula (for ground-level launch):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#angle-dependence","text":"Maximum range occurs at \\(\\theta = 45\u00b0\\) (when \\(\\sin(2\\theta) = 1\\) ) Range is symmetric around \\(45\u00b0\\) (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) give same range) Zero range at \\(0\u00b0\\) and \\(90\u00b0\\) (purely horizontal or vertical launch)","title":"Angle dependence:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-effects","text":"Velocity: Range \\(\\propto v_0^2\\) (doubling velocity quadruples range) Gravity: Range \\(\\propto \\frac{1}{g}\\) (lower gravity increases range) Initial height: For \\(h_0 > 0\\) , optimal angle \\(< 45\u00b0\\)","title":"Parameter effects:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports-applications","text":"Basketball: Different shooting angles for different distances Golf: Launch angles vary by club and desired trajectory Soccer: Kick angles affect distance and height of passes/shots","title":"Sports applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering-applications","text":"Water fountains: Different nozzle angles create different arc patterns Irrigation systems: Spray patterns optimized for coverage Catapults and trebuchets: Medieval engineers used these principles","title":"Engineering applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#space-exploration","text":"Moon ( \\(g \\approx 1.6 \\text{ m/s}^2\\) ): Same throw goes about \\(6\\times\\) further than on Earth Mars ( \\(g \\approx 3.7 \\text{ m/s}^2\\) ): Same throw goes about \\(2.7\\times\\) further than on Earth","title":"Space exploration:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-approach","text":"Created Python functions to calculate trajectories and ranges Used NumPy for calculations and Matplotlib for visualization","title":"Computational approach:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-visualizations","text":"Range vs. angle curve showing maximum at \\(45\u00b0\\) Multiple trajectory paths at different launch angles Parameter variation studies showing effects of initial velocity and gravity","title":"Key visualizations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation-capabilities","text":"Can predict range for any combination of velocity, angle, and gravity Visualizes trajectory shapes for different launch conditions Compares projectile behavior across different environments","title":"Simulation capabilities:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#current-limitations","text":"No air resistance (unrealistic for many real scenarios) Constant gravitational field (only accurate near Earth's surface) No accounting for wind or other external forces","title":"Current limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-improvements","text":"Add air resistance (drag proportional to velocity or velocity squared) Allow for uneven terrain (different launch and landing heights) Include wind effects and Magnus force (for spinning projectiles) Use numerical methods for scenarios without analytical solutions","title":"Possible improvements:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-implementation","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt #------------------------------------------------------------------------- # PART 1: Basic Functions for Projectile Motion #------------------------------------------------------------------------- def calculate_range(initial_velocity, angle_degrees, gravity=9.81): \"\"\" Calculate the horizontal range of a projectile launched from ground level. Parameters: initial_velocity: Initial speed in m/s angle_degrees: Launch angle in degrees gravity: Gravitational acceleration in m/s^2 (default: Earth's gravity) Returns: The horizontal range in meters \"\"\" # Convert angle from degrees to radians angle_radians = np.radians(angle_degrees) # Apply the range formula: R = (v0^2 * sin(2\u03b8)) / g horizontal_range = (initial_velocity**2 * np.sin(2 * angle_radians)) / gravity return horizontal_range #------------------------------------------------------------------------- # PART 2: Visualization Functions #------------------------------------------------------------------------- def plot_range_vs_angle(): \"\"\" Create a plot showing how range varies with launch angle. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Create an array of angles from 0 to 90 degrees angles = np.linspace(0, 90, 180) # Calculate range for each angle ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Find the maximum range and its corresponding angle max_range_index = np.argmax(ranges) max_range = ranges[max_range_index] optimal_angle = angles[max_range_index] # Create the plot plt.figure(figsize=(10, 6)) plt.plot(angles, ranges) # Mark the optimal angle on the plot plt.scatter(optimal_angle, max_range, color='red', s=50, zorder=5) plt.annotate(f'Optimal angle: {optimal_angle:.1f}\u00b0\\nMax range: {max_range:.2f} m', xy=(optimal_angle, max_range), xytext=(optimal_angle+5, max_range*0.9), arrowprops=dict(arrowstyle='->')) # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Range vs. Launch Angle (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) # Save and display the plot plt.savefig('range_vs_angle.png', dpi=300) plt.show() def plot_single_trajectory(): \"\"\" Plot the trajectory of a projectile launched at 45 degrees. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angle_degrees = 45 # Launch angle in degrees gravity = 9.81 # Earth's gravity in m/s^2 # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight (when projectile returns to ground) time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points from launch to landing time_points = np.linspace(0, time_of_flight, 100) # Calculate x and y positions at each time point x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Create the plot plt.figure(figsize=(10, 6)) plt.plot(x_positions, y_positions) # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectory (Initial Velocity = {initial_velocity} m/s, Angle = {angle_degrees}\u00b0)') plt.grid(True) plt.axis('equal') # Equal scaling for x and y # Save and display the plot plt.savefig('trajectory_45deg.png', dpi=300) plt.show() def plot_multiple_trajectories(): \"\"\" Plot multiple trajectories at different launch angles. \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s gravity = 9.81 # Earth's gravity in m/s^2 # Different launch angles to compare angle_list = [15, 30, 45, 60, 75] # Create the plot plt.figure(figsize=(10, 6)) # Plot trajectory for each angle for angle_degrees in angle_list: # Convert angle to radians angle_radians = np.radians(angle_degrees) # Calculate time of flight time_of_flight = 2 * initial_velocity * np.sin(angle_radians) / gravity # Create time points time_points = np.linspace(0, time_of_flight, 100) # Calculate positions x_positions = initial_velocity * np.cos(angle_radians) * time_points y_positions = initial_velocity * np.sin(angle_radians) * time_points - 0.5 * gravity * time_points**2 # Plot this trajectory plt.plot(x_positions, y_positions, label=f'Angle = {angle_degrees}\u00b0') # Add labels and title plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title(f'Projectile Trajectories at Different Angles (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('multiple_trajectories.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 3: Parameter Analysis #------------------------------------------------------------------------- def study_velocity_effect(): \"\"\" Investigate how initial velocity affects the range. \"\"\" # Define parameters gravity = 9.81 # Earth's gravity in m/s^2 angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Create the plot plt.figure(figsize=(10, 6)) # Analyze different initial velocities for velocity in [10, 20, 30]: # Calculate range for each angle at this velocity ranges = [] for angle in angles: range_value = calculate_range(velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this velocity plt.plot(angles, ranges, label=f'Initial Velocity = {velocity} m/s') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title('Effect of Initial Velocity on Projectile Range') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('velocity_effect.png', dpi=300) plt.show() def study_gravity_effect(): \"\"\" Investigate how gravity affects the range (different planets). \"\"\" # Define parameters initial_velocity = 20.0 # Initial velocity in m/s angles = np.linspace(0, 90, 180) # Angles from 0 to 90 degrees # Gravity values for different celestial bodies (in m/s\u00b2) gravity_values = { 'Earth': 9.81, 'Mars': 3.7, 'Moon': 1.6 } # Create the plot plt.figure(figsize=(10, 6)) # Analyze different gravity values for planet, gravity in gravity_values.items(): # Calculate range for each angle with this gravity ranges = [] for angle in angles: range_value = calculate_range(initial_velocity, angle, gravity) ranges.append(range_value) # Plot the range curve for this gravity plt.plot(angles, ranges, label=f'{planet} (g = {gravity} m/s\u00b2)') # Add labels and title plt.xlabel('Launch Angle (degrees)') plt.ylabel('Horizontal Range (meters)') plt.title(f'Effect of Gravity on Projectile Range (Initial Velocity = {initial_velocity} m/s)') plt.grid(True) plt.legend() # Save and display the plot plt.savefig('gravity_effect.png', dpi=300) plt.show() #------------------------------------------------------------------------- # PART 4: Main Execution #------------------------------------------------------------------------- if __name__ == \"__main__\": print(\"=== Investigating the Range as a Function of the Angle of Projection ===\") # 1. Plot range vs. angle relationship print(\"\\n1. Analyzing how range depends on launch angle...\") plot_range_vs_angle() # 2. Plot single trajectory at optimal angle print(\"\\n2. Plotting trajectory at the optimal angle (45\u00b0)...\") plot_single_trajectory() # 3. Compare trajectories at different angles print(\"\\n3. Comparing trajectories at different launch angles...\") plot_multiple_trajectories() # 4. Study parameter effects print(\"\\n4. Studying how initial velocity affects range...\") study_velocity_effect() print(\"\\n5. Studying how gravity affects range (different planets)...\") study_gravity_effect() print(\"\\nAnalysis complete! All graphs have been generated.\")","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum 1. Theoretical Foundation Basic Pendulum Model A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve. Resonance Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing 2. Different Behaviors Effect of Damping Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates Effect of Force Strength Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable Effect of Force Frequency Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements Chaos When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random) 3. Real-World Applications Engineering Examples Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy Similar Systems Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings 4. Computer Simulation Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior Key Visualizations Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum() 5. Limitations and Extensions Current Limitations Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force Possible Improvements Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other Summary The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"","title":"Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#basic-pendulum-model","text":"A forced damped pendulum consists of: A mass hanging from a pivot point Damping (friction) that slows the motion An external force pushing the pendulum periodically The motion is described by the equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t)\\] Where: \\(\\theta\\) is the angle from vertical \\(b\\) is the damping coefficient (friction) \\(g\\) is gravity and \\(L\\) is length \\(A\\) is the strength of the external force \\(\\omega\\) is how quickly the external force oscillates For small angles, we can simplify by replacing \\(\\sin(\\theta)\\) with \\(\\theta\\) , making the equation easier to solve.","title":"Basic Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the external force pushes at just the right frequency: Each push adds to the pendulum's motion The amplitude becomes much larger Similar to pushing someone on a swing with the right timing","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-different-behaviors","text":"","title":"2. Different Behaviors"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping","text":"Low damping : Pendulum swings for a long time before stopping Medium damping : Pendulum gradually slows down High damping : Pendulum moves sluggishly and barely oscillates","title":"Effect of Damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-strength","text":"Weak force : Pendulum follows a simple, predictable path Medium force : More complex motion appears Strong force : Can lead to chaotic motion where the pendulum becomes unpredictable","title":"Effect of Force Strength"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-force-frequency","text":"Slow frequency : Pendulum follows the force easily Resonant frequency : Creates largest swings Fast frequency : Pendulum can't keep up, resulting in small movements","title":"Effect of Force Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos","text":"When conditions are right, the pendulum can show chaotic behavior: Extremely sensitive to starting conditions Long-term motion becomes unpredictable Small changes lead to completely different patterns Still governed by deterministic physics (not random)","title":"Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#engineering-examples","text":"Building stabilizers : Large pendulums in skyscrapers reduce swaying during earthquakes and strong winds Clocks : Pendulums provide regular timing Energy harvesting : Converting oscillations into electrical energy","title":"Engineering Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#similar-systems","text":"Suspension systems in vehicles Electrical circuits with inductors, resistors, and capacitors (RLC circuits) Musical instruments like the vibration of strings","title":"Similar Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computer-simulation","text":"Our Python program simulates the pendulum by: Breaking down the complex motion into small time steps Calculating position and velocity at each step Creating visualizations to understand the behavior","title":"4. Computer Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-visualizations","text":"Motion graphs : Show how the angle changes over time Phase diagrams : Plot angle vs. speed to reveal patterns Poincar\u00e9 sections : Take \"snapshots\" of the system at regular intervals to detect chaos","title":"Key Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum differential equation def pendulum_ode(t, state, b, g, L, A, omega): \"\"\" state[0] = angle (theta) state[1] = angular velocity (omega) \"\"\" theta, theta_dot = state theta_double_dot = A * np.cos(omega * t) - b * theta_dot - (g / L) * np.sin(theta) return [theta_dot, theta_double_dot] # Simulation function def simulate_pendulum(b, A, omega, initial_angle=0.5, time=50): \"\"\"Simulate pendulum with given parameters\"\"\" g, L = 9.81, 1.0 # Fixed gravity and length # Solve the differential equation solution = solve_ivp( lambda t, y: pendulum_ode(t, y, b, g, L, A, omega), (0, time), [initial_angle, 0], # Initial angle and zero velocity t_eval=np.linspace(0, time, 1000) ) return solution # Main function to create all plots def analyze_pendulum(): # Create figure with three plots fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # 1. Compare different damping values damping_values = [0.05, 0.5, 2.0] labels = [\"Low Damping\", \"Medium Damping\", \"High Damping\"] omega = 2.0 # Fixed driving frequency for b, label in zip(damping_values, labels): sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 0].plot(sol.t, sol.y[0], label=label) axes[0, 0].set_title(\"Effect of Damping\") axes[0, 0].set_xlabel(\"Time\") axes[0, 0].set_ylabel(\"Angle\") axes[0, 0].legend() axes[0, 0].grid(True) # 2. Compare different forcing frequencies b = 0.2 # Fixed damping natural_freq = np.sqrt(9.81/1.0) # Natural frequency = sqrt(g/L) frequency_ratios = [0.5, 1.0, 1.5] labels = [\"Below Resonance\", \"At Resonance\", \"Above Resonance\"] for ratio, label in zip(frequency_ratios, labels): omega = ratio * natural_freq sol = simulate_pendulum(b=b, A=0.5, omega=omega) axes[0, 1].plot(sol.t, sol.y[0], label=label) axes[0, 1].set_title(\"Effect of Driving Frequency\") axes[0, 1].set_xlabel(\"Time\") axes[0, 1].set_ylabel(\"Angle\") axes[0, 1].legend() axes[0, 1].grid(True) # 3. Regular vs chaotic motion # Regular motion sol_regular = simulate_pendulum(b=0.2, A=0.3, omega=0.8*natural_freq) # Chaotic motion sol_chaotic = simulate_pendulum(b=0.2, A=1.5, omega=2/3*natural_freq, time=100) # Plot regular motion axes[1, 0].plot(sol_regular.t, sol_regular.y[0]) axes[1, 0].set_title(\"Regular Motion\") axes[1, 0].set_xlabel(\"Time\") axes[1, 0].set_ylabel(\"Angle\") axes[1, 0].grid(True) # Plot chaotic motion axes[1, 1].plot(sol_chaotic.t, sol_chaotic.y[0]) axes[1, 1].set_title(\"Chaotic Motion\") axes[1, 1].set_xlabel(\"Time\") axes[1, 1].set_ylabel(\"Angle\") axes[1, 1].grid(True) plt.tight_layout() plt.savefig('pendulum_analysis.png', dpi=300) plt.show() # 4. Bonus: Phase portrait for chaotic motion plt.figure(figsize=(8, 8)) plt.plot(sol_chaotic.y[0], sol_chaotic.y[1]) plt.title(\"Phase Portrait - Chaotic Motion\") plt.xlabel(\"Angle\") plt.ylabel(\"Angular Velocity\") plt.grid(True) plt.savefig('phase_portrait.png', dpi=300) plt.show() if __name__ == \"__main__\": analyze_pendulum()","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#current-limitations","text":"Assumes idealized damping (proportional to velocity) Doesn't account for air resistance at high speeds Assumes perfect, consistent external force","title":"Current Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-improvements","text":"Add more realistic friction models Include different types of external forces (not just cosine waves) Study coupled pendulums that affect each other","title":"Possible Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The forced damped pendulum shows how a simple system can exhibit remarkable behaviors: Simple harmonic motion with small forces Resonance when frequency matches natural motion Chaos with strong forces and the right conditions By changing parameters like damping, force strength, and frequency, we observe a wide range of behaviors that help us understand many physical systems.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius: Kepler's Third Law 1. Theoretical Foundation Derivation of Kepler's Third Law for Circular Orbits To derive the relationship between orbital period and orbital radius, we begin with Newton's Law of Universal Gravitation and the principles of circular motion. For a body of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force necessary for circular motion: \\[ F_{gravitational} = F_{centripetal} \\] \\[ \\frac{G \\cdot M \\cdot m}{r^2} = m \\cdot \\frac{v^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity Simplifying by canceling \\(m\\) from both sides: \\[ \\frac{G \\cdot M}{r^2} = \\frac{v^2}{r} \\] \\[ \\frac{G \\cdot M}{r} = v^2 \\] For circular motion, the orbital period \\(T\\) relates to the orbital radius and velocity by: \\[ T = \\frac{2\\pi r}{v} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substituting our expression for \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^2}{\\frac{G \\cdot M}{r}} = \\frac{4\\pi^2 r^3}{G \\cdot M} \\] This gives us Kepler's Third Law: \\[ T^2 = \\left(\\frac{4\\pi^2}{G \\cdot M}\\right) \\cdot r^3 \\] This shows that \\(T^2 \\propto r^3\\) , or the square of the orbital period is proportional to the cube of the orbital radius . For different bodies orbiting the same central mass (e.g., different planets around the Sun), the term \\(\\frac{4\\pi^2}{G \\cdot M}\\) is constant, giving us: \\[ \\frac{T^2}{r^3} = \\text{constant} \\] This is the formulation that Kepler originally discovered through observational data, before Newton provided the theoretical explanation. 2. Astronomical Implications Determining Planetary Masses Kepler's Third Law provides a powerful method for determining the masses of celestial bodies. If we know the orbital period and radius of an orbiting body, we can calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] This allows astronomers to: - Calculate the Sun's mass by observing planetary orbits - Determine the masses of other stars by observing their planetary systems - Calculate the masses of planets by observing their moons Determining Astronomical Distances Given the mass of a central body and the orbital period of an orbiting body, we can calculate the orbital radius: \\[ r = \\sqrt[3]{\\frac{G \\cdot M \\cdot T^2}{4\\pi^2}} \\] This principle helps in: - Calculating distances within our Solar System - Estimating the size of exoplanetary systems - Mapping the structure of binary star systems Characterizing Exoplanetary Systems For exoplanets, where direct measurement of orbital radius is challenging, astronomers can: - Measure the orbital period through transit timing or radial velocity methods - Estimate the star's mass through spectroscopic analysis - Calculate the orbital radius using Kepler's Third Law This has been crucial in mapping the architecture of thousands of exoplanetary systems discovered to date. 3. Real-World Examples The Earth-Moon System For the Earth-Moon system: - Moon's mean orbital radius: \\(r \\approx 384,400\\) km - Moon's orbital period: \\(T \\approx 27.32\\) days \\(\\approx 2,360,448\\) seconds Using Kepler's Third Law: \\[ M_{Earth} = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] \\[ M_{Earth} \\approx \\frac{4\\pi^2 \\cdot (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] This closely matches Earth's known mass, confirming the relationship. Planets in the Solar System Planet Mean Orbital Radius (AU) Orbital Period (years) \\(T^2/r^3\\) Mercury 0.387 0.241 1.00 Venus 0.723 0.615 1.00 Earth 1.000 1.000 1.00 Mars 1.524 1.881 1.00 Jupiter 5.203 11.86 1.00 Saturn 9.537 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.07 164.8 1.00 The \\(T^2/r^3\\) value is normalized to 1 for all planets, demonstrating that the relationship holds throughout the Solar System. Jupiter's Moons Jupiter's four largest moons (the Galilean moons) provide another excellent example: Moon Mean Orbital Radius (km) Orbital Period (days) \\(T^2/r^3\\) (constant) Io 421,800 1.769 \\(1.77 \\times 10^{-16}\\) Europa 671,100 3.551 \\(1.77 \\times 10^{-16}\\) Ganymede 1,070,400 7.155 \\(1.77 \\times 10^{-16}\\) Callisto 1,882,700 16.69 \\(1.77 \\times 10^{-16}\\) The constant \\(T^2/r^3\\) value across all four moons confirms Kepler's Third Law and allows us to calculate Jupiter's mass. 4. Extension to Elliptical Orbits Generalized Form of Kepler's Third Law For elliptical orbits, Kepler's Third Law still applies, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot M} \\] This means the relationship between period and semi-major axis holds regardless of the eccentricity of the orbit. Implications for Comets and Asteroids Bodies with highly elliptical orbits, such as comets, still follow Kepler's Third Law. For example, Halley's Comet: - Orbital period: ~76 years - Semi-major axis: ~17.8 AU This relationship allows astronomers to predict when comets will return to the inner Solar System, even with very elongated orbits. Binary Star Systems For binary star systems, where two stars orbit their common center of mass, a modified version applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot (M_1 + M_2)} \\] Where \\(M_1\\) and \\(M_2\\) are the masses of the two stars and \\(a\\) is the semi-major axis of their orbit. 5. Computational Analysis In the accompanying Python simulation, we demonstrate: Visualization of circular orbits for various orbital radii Verification of the \\(T^2 \\propto r^3\\) relationship Application to real planetary data Interactive exploration of how changing parameters affects orbital dynamics The simulation confirms that Kepler's Third Law holds across a wide range of scales, from satellite orbits around Earth to planets orbiting distant stars. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) def calculate_orbital_period(radius, central_mass): \"\"\" Calculate orbital period using Kepler's Third Law. Parameters: radius (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def generate_circular_orbit(radius, num_points=1000): \"\"\" Generate points for a circular orbit. Parameters: radius (float): Orbital radius num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y def plot_circular_orbits(radii, central_mass, planet_names=None): \"\"\" Plot multiple circular orbits with different radii. Parameters: radii (list): List of orbital radii central_mass (float): Mass of the central body planet_names (list): Optional list of names for the orbiting bodies \"\"\" plt.figure(figsize=(10, 10)) # Plot central body plt.plot(0, 0, 'yo', markersize=15, label='Central Body') # Calculate periods and plot orbits periods = [] for i, radius in enumerate(radii): x, y = generate_circular_orbit(radius) period = calculate_orbital_period(radius, central_mass) periods.append(period) name = f\"Body {i+1}\" if planet_names is None else planet_names[i] plt.plot(x, y, '--', alpha=0.6) plt.plot(x[0], y[0], 'o', markersize=8, label=f\"{name}: T = {period:.2e} s\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbits with Different Radii') plt.grid(True, alpha=0.3) plt.axis('equal') plt.legend() plt.tight_layout() plt.savefig('circular_orbits.png', dpi=300) plt.show() return radii, periods def verify_keplers_third_law(radii, periods): \"\"\" Verify Kepler's Third Law by plotting T^2 vs r^3. Parameters: radii (list): List of orbital radii periods (list): List of corresponding orbital periods \"\"\" # Calculate T^2 and r^3 t_squared = [period**2 for period in periods] r_cubed = [radius**3 for radius in radii] # Calculate the constant T^2/r^3 constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, t_squared, s=80, alpha=0.7) # Fit a line to verify the relationship coefficients = np.polyfit(r_cubed, t_squared, 1) poly = np.poly1d(coefficients) r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) plt.plot(r3_line, poly(r3_line), 'r--') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, alpha=0.3) # Add text showing the relationship plt.text(0.05, 0.9, f'T\u00b2 = {coefficients[0]:.4e} \u00d7 r\u00b3 + {coefficients[1]:.4e}', transform=plt.gca().transAxes, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) plt.tight_layout() plt.savefig('keplers_third_law_verification.png', dpi=300) plt.show() return constants def solar_system_verification(): \"\"\" Verify Kepler's Third Law using real Solar System data. \"\"\" # Solar system data (planets) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Semi-major axes in AU radii_au = [0.387, 0.723, 1.000, 1.524, 5.203, 9.537, 19.19, 30.07] # Convert AU to meters au_to_m = 1.496e11 radii_m = [r * au_to_m for r in radii_au] # Orbital periods in years periods_yr = [0.241, 0.615, 1.000, 1.881, 11.86, 29.46, 84.01, 164.8] # Convert years to seconds yr_to_s = 365.25 * 24 * 3600 periods_s = [p * yr_to_s for p in periods_yr] # Calculate T^2/r^3 for each planet (should be constant) t_squared = [p**2 for p in periods_s] r_cubed = [r**3 for r in radii_m] constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Sun's mass sun_mass = 1.989e30 # kg # Theoretical constant theoretical_constant = 4 * np.pi**2 / (G * sun_mass) # Create a table plt.figure(figsize=(12, 8)) plt.axis('off') table_data = [] table_data.append(['Planet', 'Radius (AU)', 'Period (years)', 'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)', 'Ratio to Earth']) for i, planet in enumerate(planets): # Calculate ratio of T\u00b2/r\u00b3 to Earth's value ratio = constants[i] / constants[2] # Earth is index 2 table_data.append([planet, f\"{radii_au[i]:.3f}\", f\"{periods_yr[i]:.3f}\", f\"{constants[i]:.4e}\", f\"{ratio:.6f}\"]) # Plot the table table = plt.table(cellText=table_data, loc='center', cellLoc='center', colWidths=[0.15, 0.15, 0.15, 0.22, 0.15]) table.auto_set_font_size(False) table.set_fontsize(10) table.scale(1, 1.5) plt.title(\"Verification of Kepler's Third Law in the Solar System\", y=0.8) # Add text showing the theoretical constant plt.text(0.5, 0.1, f'Theoretical value of T\u00b2/r\u00b3 = 4\u03c0\u00b2/(G\u00b7M_\u2609) = {theoretical_constant:.4e} s\u00b2/m\u00b3', horizontalalignment='center', fontsize=12, bbox=dict(facecolor='white', alpha=0.8), transform=plt.gcf().transFigure) plt.tight_layout() plt.savefig('solar_system_verification.png', dpi=300) plt.show() # Plot T^2 vs r^3 for Solar System plt.figure(figsize=(10, 6)) plt.scatter(r_cubed, t_squared, s=100, alpha=0.7) # Add planet labels for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Plot the theoretical line r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) t2_line = theoretical_constant * r3_line plt.plot(r3_line, t2_line, 'r--', label=f'T\u00b2 = {theoretical_constant:.4e} \u00d7 r\u00b3') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('Kepler\\'s Third Law for Solar System Planets') plt.grid(True, alpha=0.3) plt.legend() # Use log scale due to wide range of values plt.xscale('log') plt.yscale('log') plt.tight_layout() plt.savefig('solar_system_plot.png', dpi=300) plt.show() return planets, radii_au, periods_yr, constants def animate_orbit(radius, central_mass, num_frames=200): \"\"\" Create an animation of an orbiting body. Parameters: radius (float): Orbital radius central_mass (float): Mass of the central body num_frames (int): Number of frames in the animation Returns: FuncAnimation: Animation object \"\"\" # Calculate orbital period period = calculate_orbital_period(radius, central_mass) # Generate the orbit theta = np.linspace(0, 2*np.pi, num_frames) x = radius * np.cos(theta) y = radius * np.sin(theta) # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-radius*1.2, radius*1.2) ax.set_ylim(-radius*1.2, radius*1.2) ax.grid(True, alpha=0.3) # Plot central body ax.plot(0, 0, 'yo', markersize=15) # Plot the orbit path ax.plot(x, y, '--', alpha=0.3) # Create moving point for the orbiting body point, = ax.plot([], [], 'bo', markersize=10) # Text for displaying time time_text = ax.text(0.05, 0.95, '', transform=ax.transAxes) # Text for displaying period information ax.text(0.05, 0.90, f'Orbital period: {period:.2e} s', transform=ax.transAxes, bbox=dict(facecolor='white', alpha=0.7)) def init(): point.set_data([], []) time_text.set_text('') return point, time_text def update(frame): point.set_data(x[frame], y[frame]) time_text.set_text(f'Time: {frame/num_frames * period:.2e} s') return point, time_text ani = FuncAnimation(fig, update, frames=num_frames, init_func=init, interval=50, blit=True) plt.title(f'Orbital Motion (r = {radius:.2e} m)') plt.tight_layout() return ani def main(): \"\"\"Main function to run all simulations.\"\"\" print(\"Kepler's Third Law Simulation\") print(\"-\" * 30) # Earth-like central mass earth_mass = 5.972e24 # kg # Simulate orbits of different satellites print(\"\\n1. Simulating Earth Satellites\") satellite_radii = [7.0e6, 1.0e7, 2.0e7, 4.2e7] # Orbit radii in meters satellite_names = [\"Low Earth Orbit\", \"Mid Earth Orbit\", \"Geostationary\", \"Lunar Distance\"] radii, periods = plot_circular_orbits(satellite_radii, earth_mass, satellite_names) constants = verify_keplers_third_law(radii, periods) print(f\"Average T\u00b2/r\u00b3 constant: {np.mean(constants):.4e} s\u00b2/m\u00b3\") print(f\"Theoretical value: {4 * np.pi**2 / (G * earth_mass):.4e} s\u00b2/m\u00b3\") # Verify with Solar System data print(\"\\n2. Verifying with Solar System Data\") solar_system_verification() print(\"\\nSimulation complete! All plots have been saved.\") if __name__ == \"__main__\": main()","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"To derive the relationship between orbital period and orbital radius, we begin with Newton's Law of Universal Gravitation and the principles of circular motion. For a body of mass \\(m\\) orbiting a central body of mass \\(M\\) in a circular orbit of radius \\(r\\) , the gravitational force provides the centripetal force necessary for circular motion: \\[ F_{gravitational} = F_{centripetal} \\] \\[ \\frac{G \\cdot M \\cdot m}{r^2} = m \\cdot \\frac{v^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity Simplifying by canceling \\(m\\) from both sides: \\[ \\frac{G \\cdot M}{r^2} = \\frac{v^2}{r} \\] \\[ \\frac{G \\cdot M}{r} = v^2 \\] For circular motion, the orbital period \\(T\\) relates to the orbital radius and velocity by: \\[ T = \\frac{2\\pi r}{v} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substituting our expression for \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^2}{\\frac{G \\cdot M}{r}} = \\frac{4\\pi^2 r^3}{G \\cdot M} \\] This gives us Kepler's Third Law: \\[ T^2 = \\left(\\frac{4\\pi^2}{G \\cdot M}\\right) \\cdot r^3 \\] This shows that \\(T^2 \\propto r^3\\) , or the square of the orbital period is proportional to the cube of the orbital radius . For different bodies orbiting the same central mass (e.g., different planets around the Sun), the term \\(\\frac{4\\pi^2}{G \\cdot M}\\) is constant, giving us: \\[ \\frac{T^2}{r^3} = \\text{constant} \\] This is the formulation that Kepler originally discovered through observational data, before Newton provided the theoretical explanation.","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-planetary-masses","text":"Kepler's Third Law provides a powerful method for determining the masses of celestial bodies. If we know the orbital period and radius of an orbiting body, we can calculate the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] This allows astronomers to: - Calculate the Sun's mass by observing planetary orbits - Determine the masses of other stars by observing their planetary systems - Calculate the masses of planets by observing their moons","title":"Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#determining-astronomical-distances","text":"Given the mass of a central body and the orbital period of an orbiting body, we can calculate the orbital radius: \\[ r = \\sqrt[3]{\\frac{G \\cdot M \\cdot T^2}{4\\pi^2}} \\] This principle helps in: - Calculating distances within our Solar System - Estimating the size of exoplanetary systems - Mapping the structure of binary star systems","title":"Determining Astronomical Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#characterizing-exoplanetary-systems","text":"For exoplanets, where direct measurement of orbital radius is challenging, astronomers can: - Measure the orbital period through transit timing or radial velocity methods - Estimate the star's mass through spectroscopic analysis - Calculate the orbital radius using Kepler's Third Law This has been crucial in mapping the architecture of thousands of exoplanetary systems discovered to date.","title":"Characterizing Exoplanetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-earth-moon-system","text":"For the Earth-Moon system: - Moon's mean orbital radius: \\(r \\approx 384,400\\) km - Moon's orbital period: \\(T \\approx 27.32\\) days \\(\\approx 2,360,448\\) seconds Using Kepler's Third Law: \\[ M_{Earth} = \\frac{4\\pi^2 r^3}{G \\cdot T^2} \\] \\[ M_{Earth} \\approx \\frac{4\\pi^2 \\cdot (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] This closely matches Earth's known mass, confirming the relationship.","title":"The Earth-Moon System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"Planet Mean Orbital Radius (AU) Orbital Period (years) \\(T^2/r^3\\) Mercury 0.387 0.241 1.00 Venus 0.723 0.615 1.00 Earth 1.000 1.000 1.00 Mars 1.524 1.881 1.00 Jupiter 5.203 11.86 1.00 Saturn 9.537 29.46 1.00 Uranus 19.19 84.01 1.00 Neptune 30.07 164.8 1.00 The \\(T^2/r^3\\) value is normalized to 1 for all planets, demonstrating that the relationship holds throughout the Solar System.","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#jupiters-moons","text":"Jupiter's four largest moons (the Galilean moons) provide another excellent example: Moon Mean Orbital Radius (km) Orbital Period (days) \\(T^2/r^3\\) (constant) Io 421,800 1.769 \\(1.77 \\times 10^{-16}\\) Europa 671,100 3.551 \\(1.77 \\times 10^{-16}\\) Ganymede 1,070,400 7.155 \\(1.77 \\times 10^{-16}\\) Callisto 1,882,700 16.69 \\(1.77 \\times 10^{-16}\\) The constant \\(T^2/r^3\\) value across all four moons confirms Kepler's Third Law and allows us to calculate Jupiter's mass.","title":"Jupiter's Moons"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extension-to-elliptical-orbits","text":"","title":"4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generalized-form-of-keplers-third-law","text":"For elliptical orbits, Kepler's Third Law still applies, but the radius \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot M} \\] This means the relationship between period and semi-major axis holds regardless of the eccentricity of the orbit.","title":"Generalized Form of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-comets-and-asteroids","text":"Bodies with highly elliptical orbits, such as comets, still follow Kepler's Third Law. For example, Halley's Comet: - Orbital period: ~76 years - Semi-major axis: ~17.8 AU This relationship allows astronomers to predict when comets will return to the inner Solar System, even with very elongated orbits.","title":"Implications for Comets and Asteroids"},{"location":"1%20Physics/2%20Gravity/Problem_1/#binary-star-systems","text":"For binary star systems, where two stars orbit their common center of mass, a modified version applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G \\cdot (M_1 + M_2)} \\] Where \\(M_1\\) and \\(M_2\\) are the masses of the two stars and \\(a\\) is the semi-major axis of their orbit.","title":"Binary Star Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-computational-analysis","text":"In the accompanying Python simulation, we demonstrate: Visualization of circular orbits for various orbital radii Verification of the \\(T^2 \\propto r^3\\) relationship Application to real planetary data Interactive exploration of how changing parameters affects orbital dynamics The simulation confirms that Kepler's Third Law holds across a wide range of scales, from satellite orbits around Earth to planets orbiting distant stars. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from mpl_toolkits.mplot3d import Axes3D # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) def calculate_orbital_period(radius, central_mass): \"\"\" Calculate orbital period using Kepler's Third Law. Parameters: radius (float): Orbital radius in meters central_mass (float): Mass of the central body in kg Returns: float: Orbital period in seconds \"\"\" return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def generate_circular_orbit(radius, num_points=1000): \"\"\" Generate points for a circular orbit. Parameters: radius (float): Orbital radius num_points (int): Number of points to generate Returns: tuple: Arrays of x and y coordinates \"\"\" theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y def plot_circular_orbits(radii, central_mass, planet_names=None): \"\"\" Plot multiple circular orbits with different radii. Parameters: radii (list): List of orbital radii central_mass (float): Mass of the central body planet_names (list): Optional list of names for the orbiting bodies \"\"\" plt.figure(figsize=(10, 10)) # Plot central body plt.plot(0, 0, 'yo', markersize=15, label='Central Body') # Calculate periods and plot orbits periods = [] for i, radius in enumerate(radii): x, y = generate_circular_orbit(radius) period = calculate_orbital_period(radius, central_mass) periods.append(period) name = f\"Body {i+1}\" if planet_names is None else planet_names[i] plt.plot(x, y, '--', alpha=0.6) plt.plot(x[0], y[0], 'o', markersize=8, label=f\"{name}: T = {period:.2e} s\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Circular Orbits with Different Radii') plt.grid(True, alpha=0.3) plt.axis('equal') plt.legend() plt.tight_layout() plt.savefig('circular_orbits.png', dpi=300) plt.show() return radii, periods def verify_keplers_third_law(radii, periods): \"\"\" Verify Kepler's Third Law by plotting T^2 vs r^3. Parameters: radii (list): List of orbital radii periods (list): List of corresponding orbital periods \"\"\" # Calculate T^2 and r^3 t_squared = [period**2 for period in periods] r_cubed = [radius**3 for radius in radii] # Calculate the constant T^2/r^3 constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Plot T^2 vs r^3 plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, t_squared, s=80, alpha=0.7) # Fit a line to verify the relationship coefficients = np.polyfit(r_cubed, t_squared, 1) poly = np.poly1d(coefficients) r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) plt.plot(r3_line, poly(r3_line), 'r--') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Verification of Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True, alpha=0.3) # Add text showing the relationship plt.text(0.05, 0.9, f'T\u00b2 = {coefficients[0]:.4e} \u00d7 r\u00b3 + {coefficients[1]:.4e}', transform=plt.gca().transAxes, fontsize=12, bbox=dict(facecolor='white', alpha=0.8)) plt.tight_layout() plt.savefig('keplers_third_law_verification.png', dpi=300) plt.show() return constants def solar_system_verification(): \"\"\" Verify Kepler's Third Law using real Solar System data. \"\"\" # Solar system data (planets) planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] # Semi-major axes in AU radii_au = [0.387, 0.723, 1.000, 1.524, 5.203, 9.537, 19.19, 30.07] # Convert AU to meters au_to_m = 1.496e11 radii_m = [r * au_to_m for r in radii_au] # Orbital periods in years periods_yr = [0.241, 0.615, 1.000, 1.881, 11.86, 29.46, 84.01, 164.8] # Convert years to seconds yr_to_s = 365.25 * 24 * 3600 periods_s = [p * yr_to_s for p in periods_yr] # Calculate T^2/r^3 for each planet (should be constant) t_squared = [p**2 for p in periods_s] r_cubed = [r**3 for r in radii_m] constants = [t2/r3 for t2, r3 in zip(t_squared, r_cubed)] # Sun's mass sun_mass = 1.989e30 # kg # Theoretical constant theoretical_constant = 4 * np.pi**2 / (G * sun_mass) # Create a table plt.figure(figsize=(12, 8)) plt.axis('off') table_data = [] table_data.append(['Planet', 'Radius (AU)', 'Period (years)', 'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)', 'Ratio to Earth']) for i, planet in enumerate(planets): # Calculate ratio of T\u00b2/r\u00b3 to Earth's value ratio = constants[i] / constants[2] # Earth is index 2 table_data.append([planet, f\"{radii_au[i]:.3f}\", f\"{periods_yr[i]:.3f}\", f\"{constants[i]:.4e}\", f\"{ratio:.6f}\"]) # Plot the table table = plt.table(cellText=table_data, loc='center', cellLoc='center', colWidths=[0.15, 0.15, 0.15, 0.22, 0.15]) table.auto_set_font_size(False) table.set_fontsize(10) table.scale(1, 1.5) plt.title(\"Verification of Kepler's Third Law in the Solar System\", y=0.8) # Add text showing the theoretical constant plt.text(0.5, 0.1, f'Theoretical value of T\u00b2/r\u00b3 = 4\u03c0\u00b2/(G\u00b7M_\u2609) = {theoretical_constant:.4e} s\u00b2/m\u00b3', horizontalalignment='center', fontsize=12, bbox=dict(facecolor='white', alpha=0.8), transform=plt.gcf().transFigure) plt.tight_layout() plt.savefig('solar_system_verification.png', dpi=300) plt.show() # Plot T^2 vs r^3 for Solar System plt.figure(figsize=(10, 6)) plt.scatter(r_cubed, t_squared, s=100, alpha=0.7) # Add planet labels for i, planet in enumerate(planets): plt.annotate(planet, (r_cubed[i], t_squared[i]), xytext=(5, 5), textcoords='offset points') # Plot the theoretical line r3_line = np.linspace(min(r_cubed), max(r_cubed), 100) t2_line = theoretical_constant * r3_line plt.plot(r3_line, t2_line, 'r--', label=f'T\u00b2 = {theoretical_constant:.4e} \u00d7 r\u00b3') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title('Kepler\\'s Third Law for Solar System Planets') plt.grid(True, alpha=0.3) plt.legend() # Use log scale due to wide range of values plt.xscale('log') plt.yscale('log') plt.tight_layout() plt.savefig('solar_system_plot.png', dpi=300) plt.show() return planets, radii_au, periods_yr, constants def animate_orbit(radius, central_mass, num_frames=200): \"\"\" Create an animation of an orbiting body. Parameters: radius (float): Orbital radius central_mass (float): Mass of the central body num_frames (int): Number of frames in the animation Returns: FuncAnimation: Animation object \"\"\" # Calculate orbital period period = calculate_orbital_period(radius, central_mass) # Generate the orbit theta = np.linspace(0, 2*np.pi, num_frames) x = radius * np.cos(theta) y = radius * np.sin(theta) # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-radius*1.2, radius*1.2) ax.set_ylim(-radius*1.2, radius*1.2) ax.grid(True, alpha=0.3) # Plot central body ax.plot(0, 0, 'yo', markersize=15) # Plot the orbit path ax.plot(x, y, '--', alpha=0.3) # Create moving point for the orbiting body point, = ax.plot([], [], 'bo', markersize=10) # Text for displaying time time_text = ax.text(0.05, 0.95, '', transform=ax.transAxes) # Text for displaying period information ax.text(0.05, 0.90, f'Orbital period: {period:.2e} s', transform=ax.transAxes, bbox=dict(facecolor='white', alpha=0.7)) def init(): point.set_data([], []) time_text.set_text('') return point, time_text def update(frame): point.set_data(x[frame], y[frame]) time_text.set_text(f'Time: {frame/num_frames * period:.2e} s') return point, time_text ani = FuncAnimation(fig, update, frames=num_frames, init_func=init, interval=50, blit=True) plt.title(f'Orbital Motion (r = {radius:.2e} m)') plt.tight_layout() return ani def main(): \"\"\"Main function to run all simulations.\"\"\" print(\"Kepler's Third Law Simulation\") print(\"-\" * 30) # Earth-like central mass earth_mass = 5.972e24 # kg # Simulate orbits of different satellites print(\"\\n1. Simulating Earth Satellites\") satellite_radii = [7.0e6, 1.0e7, 2.0e7, 4.2e7] # Orbit radii in meters satellite_names = [\"Low Earth Orbit\", \"Mid Earth Orbit\", \"Geostationary\", \"Lunar Distance\"] radii, periods = plot_circular_orbits(satellite_radii, earth_mass, satellite_names) constants = verify_keplers_third_law(radii, periods) print(f\"Average T\u00b2/r\u00b3 constant: {np.mean(constants):.4e} s\u00b2/m\u00b3\") print(f\"Theoretical value: {4 * np.pi**2 / (G * earth_mass):.4e} s\u00b2/m\u00b3\") # Verify with Solar System data print(\"\\n2. Verifying with Solar System Data\") solar_system_verification() print(\"\\nSimulation complete! All plots have been saved.\") if __name__ == \"__main__\": main()","title":"5. Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities Motivation Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel. Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location. Mathematical Derivation and Parameters First Cosmic Velocity Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Python Implementation Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show() Graphical Representation The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}